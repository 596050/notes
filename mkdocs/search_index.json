{
    "docs": [
        {
            "location": "/", 
            "text": "Shichao's Notes\n\n\nThis site documents reading notes of the following books. Each chapter is organized as a single page; the included sections are noted with major concepts, along with personal doubts (with possible solutions figured out afterwards) and summary.\n\n\nReading Notes\n\n\nAdvanced Programming in the UNIX Environment, 3rd Edition\n\n\nby W. Richard Stevens and Stephen A. Rago\n\n\n\n\nUNIX System Overview\n\n\nUNIX Standardization and Implementations\n\n\nFile I/O\n\n\nFiles and Directories\n\n\nStandard I/O Library\n\n\nSystem Data Files and Information\n\n\n\n\nUnderstanding the Linux Kernel, Third Edition\n\n\nby Daniel P. Bovet and Marco Cesati\n\n\n\n\nIntroduction\n\n\nMemory Addressing\n\n\n\n\nUnix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)\n\n\nby W. Richard Stevens and Bill Fenner\n\n\n\n\nIntroduction\n\n\nThe Transport Layer: TCP, UDP, and SCTP\n\n\n\n\nTCP/IP Illustrated, Volume 1: The Protocols (2nd Edition)\n\n\nby Kevin R. Fall and W. Richard Stevens\n\n\n\n\nIntroduction\n\n\nThe Internet Address Architecture\n\n\n\n\nCCENT/CCNA ICND1 640-822 Official Cert Guide, Third Edition\n\n\n\n\nNetworking Fundamentals\n\n\n\n\nCCNA ICND2 Official Exam Certification Guide, Second Edition\n\n\n\n\nLAN Switching\n\n\n\n\nHacking: The Art of Exploitation, 2nd Edition\n\n\nby Jon Erickson \n\n\n\n\nIntroduction (skipped)\n\n\nProgramming\n\n\n\n\nLearning Notes\n\n\nProgramming Languages\n\n\n\n\nGolang\n\n\nBash\n\n\nC\n\n\n\n\nSoftware and Technologies\n\n\n\n\nNginx\n\n\nIptables\n\n\nVim", 
            "title": "Home"
        }, 
        {
            "location": "/#shichaos-notes", 
            "text": "This site documents reading notes of the following books. Each chapter is organized as a single page; the included sections are noted with major concepts, along with personal doubts (with possible solutions figured out afterwards) and summary.  Reading Notes  Advanced Programming in the UNIX Environment, 3rd Edition  by W. Richard Stevens and Stephen A. Rago   UNIX System Overview  UNIX Standardization and Implementations  File I/O  Files and Directories  Standard I/O Library  System Data Files and Information   Understanding the Linux Kernel, Third Edition  by Daniel P. Bovet and Marco Cesati   Introduction  Memory Addressing   Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)  by W. Richard Stevens and Bill Fenner   Introduction  The Transport Layer: TCP, UDP, and SCTP   TCP/IP Illustrated, Volume 1: The Protocols (2nd Edition)  by Kevin R. Fall and W. Richard Stevens   Introduction  The Internet Address Architecture   CCENT/CCNA ICND1 640-822 Official Cert Guide, Third Edition   Networking Fundamentals   CCNA ICND2 Official Exam Certification Guide, Second Edition   LAN Switching   Hacking: The Art of Exploitation, 2nd Edition  by Jon Erickson    Introduction (skipped)  Programming   Learning Notes  Programming Languages   Golang  Bash  C   Software and Technologies   Nginx  Iptables  Vim", 
            "title": "Shichao's Notes"
        }, 
        {
            "location": "/apue/ch1/", 
            "text": "Chapter 1. UNIX System Overview\n\n\nThis chapter gives basic Unix system concepts that are familiar to system administrators.\n\n\nSystem Calls and Library Functions\n\n\n\n\nLinux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450\n\n\nEach system call has a function of the same name in the standard C library\n\n\nAn application can either make a system call or call a library routine", 
            "title": "Chapter 1. UNIX System Overview"
        }, 
        {
            "location": "/apue/ch1/#chapter-1-unix-system-overview", 
            "text": "This chapter gives basic Unix system concepts that are familiar to system administrators.  System Calls and Library Functions   Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450  Each system call has a function of the same name in the standard C library  An application can either make a system call or call a library routine", 
            "title": "Chapter 1. UNIX System Overview"
        }, 
        {
            "location": "/apue/ch2/", 
            "text": "Chapter 2. UNIX Standardization and Implementations\n\n\nThis chapter discusses Unix standards, specifications and implementations.\n\n\nUNIX Standardization\n\n\n\n\nISO C\n\n\nIEEE POSIX\n\n\nSingle UNIX Specification (SUS): superset of the POSIX.1 standard\n\n\n\n\nLimits\n\n\n\n\nCompile-time limits\n\n\nRuntime limits", 
            "title": "Chapter 2. UNIX Standardization and Implementations"
        }, 
        {
            "location": "/apue/ch2/#chapter-2-unix-standardization-and-implementations", 
            "text": "This chapter discusses Unix standards, specifications and implementations.  UNIX Standardization   ISO C  IEEE POSIX  Single UNIX Specification (SUS): superset of the POSIX.1 standard   Limits   Compile-time limits  Runtime limits", 
            "title": "Chapter 2. UNIX Standardization and Implementations"
        }, 
        {
            "location": "/apue/ch3/", 
            "text": "Chapter 3. File I/O\n\n\nThis chapter discusses unbuffered I/O, which are not part of ISO C but are part of POSIX.1 and the Single UNIX Specification.\n\n\nFile Descriptors\n\n\n\n\nAll open files are referred to by file descriptors\n\n\nNon-negative integer\n\n\nRange from 0 to \nOPEN_MAX - 1\n. With FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, the limit is essentially infinite, bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator.\n\n\n\n\nopen\n and \nopenat\n Functions\n\n\n\n\n\noflag\n argument is formed by ORing one or more of the following constants from \nfcntl.h\n [p62]:\n\n\nRequired:\n\n\n\n\nO_RDONLY\n\n\nO_WRONLY\n\n\nO_RDWR\n\n\nO_EXEC\n\n\nO_SEARCH\n: Open for search only (applies to directories).\n\n\n\n\nOptional:\n\n\n\n\nO_APPEND\n\n\nO_CLOEXEC\n: Set the \nFD_CLOEXEC\n file descriptor flag\n\n\nO_CREAT\n: Create the file if it doesn\u2019t exist\n\n\nO_DIRECTORY\n: Generate an error if \nO_CREAT\n is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn\u2019t exist is an atomic operation\n\n\nO_EXCL\n\n\nO_NOCTTY\n\n\nO_NOFOLLOW\n\n\nO_NONBLOCK\n\n\nO_SYNC\n: Have each \nwrite\n wait for physical I/O to complete\n\n\nO_TRUNC\n\n\nO_TTY_INIT\n\n\nO_DSYNC\n\n\nO_RSYNC\n\n\n\n\nTOCTTOU\n\n\nopenat\n, for example, provides a way to avoid \ntime-of-check-to-time-of-use\n (TOCTTOU) errors. A program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call (two calls are not atomic).\n\n\nFilename and Pathname Truncation\n\n\nMost modern file systems support a maximum of 255 characters for filenames.\n\n\ncreat\n Function\n\n\n\n\n\nThis function is equivalent to:\n\n\nopen(path, O_WRONLY | O_CREAT | O_TRUNC, mode);\n\n\n\n\nWith \ncreat\n, the file is opened only for writing. To read and write a file, use [p66]:\n\n\nopen(path, O_RDWR | O_CREAT | O_TRUNC, mode);\n\n\n\n\nclose\n Function\n\n\n\n\n\nWhen a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don\u2019t explicitly close open files.\n\n\nlseek\n Function\n\n\nEvery open file has a \"current file offset\", normally a non-negative integer that measures the number of bytes from the beginning of the file.\n\n\n\n\n\nThe \nwhence\n argument can be:\n\n\n\n\nSEEK_SET\n: the file\u2019s offset is set to \noffset\n bytes from the beginning of the file\n\n\nSEEK_CUR\n: the file\u2019s offset is set to its current value plus the \noffset\n. The \noffset\n can be positive or negative.\n\n\nSEEK_END\n: the file\u2019s offset is set to the size of the file plus the \noffset\n. The \noffset\n can be positive or negative.", 
            "title": "Chapter 3. File I/O"
        }, 
        {
            "location": "/apue/ch3/#chapter-3-file-io", 
            "text": "This chapter discusses unbuffered I/O, which are not part of ISO C but are part of POSIX.1 and the Single UNIX Specification.  File Descriptors   All open files are referred to by file descriptors  Non-negative integer  Range from 0 to  OPEN_MAX - 1 . With FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, the limit is essentially infinite, bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator.   open  and  openat  Functions   oflag  argument is formed by ORing one or more of the following constants from  fcntl.h  [p62]:  Required:   O_RDONLY  O_WRONLY  O_RDWR  O_EXEC  O_SEARCH : Open for search only (applies to directories).   Optional:   O_APPEND  O_CLOEXEC : Set the  FD_CLOEXEC  file descriptor flag  O_CREAT : Create the file if it doesn\u2019t exist  O_DIRECTORY : Generate an error if  O_CREAT  is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn\u2019t exist is an atomic operation  O_EXCL  O_NOCTTY  O_NOFOLLOW  O_NONBLOCK  O_SYNC : Have each  write  wait for physical I/O to complete  O_TRUNC  O_TTY_INIT  O_DSYNC  O_RSYNC   TOCTTOU  openat , for example, provides a way to avoid  time-of-check-to-time-of-use  (TOCTTOU) errors. A program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call (two calls are not atomic).  Filename and Pathname Truncation  Most modern file systems support a maximum of 255 characters for filenames.  creat  Function   This function is equivalent to:  open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);  With  creat , the file is opened only for writing. To read and write a file, use [p66]:  open(path, O_RDWR | O_CREAT | O_TRUNC, mode);  close  Function   When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don\u2019t explicitly close open files.  lseek  Function  Every open file has a \"current file offset\", normally a non-negative integer that measures the number of bytes from the beginning of the file.   The  whence  argument can be:   SEEK_SET : the file\u2019s offset is set to  offset  bytes from the beginning of the file  SEEK_CUR : the file\u2019s offset is set to its current value plus the  offset . The  offset  can be positive or negative.  SEEK_END : the file\u2019s offset is set to the size of the file plus the  offset . The  offset  can be positive or negative.", 
            "title": "Chapter 3. File I/O"
        }, 
        {
            "location": "/apue/ch4/", 
            "text": "Chapter 4. Files and Directories\n\n\nThis chapter centers on I/O for regular files.\n\n\nrestrict\n keyword\n\n\nAdded in C99, \nrestrict\n keyword is used to tell the compiler which pointer references can be optimized, by indicating that the object to which the pointer refers is accessed in the function only via that pointer. [p26]\n\n\nstat\n, \nfstat\n, \nfstatat\n, and \nlstat\n Functions\n\n\n\n\n\n\n\nstat\n: returns a structure of information about the named file\n\n\nfstat\n: returns a structure of information about the given file descriptor\n\n\nlstat\n: similar to \nstat\n, returns information about the symbolic link, not the file referenced by the symbolic link\n\n\nfstatat\n:  return the file statistics for a pathname relative to an open directory represented by the fd argument; the flag argument controls whether symbolic links are followed\n\n\n\n\nThe \nbuf\n argument is a pointer to a \nstructure\n that we must supply. The functions fill in the structure.\n\n\nstruct stat {\n    mode_t    st_mode;\n    ino_t    st_ino;\n    dev_t    st_dev;\n    dev_t    st_rdev;\n    nlink_t    st_nlink;\n    uid_t    st_uid;\n    gid_t    st_gid;\n    off_t    st_size;\n    struct timespec    st_atim;\n    struct timespec    st_mtim;\n    struct timespec    st_ctim;\n    blksize_t    st_blksize;\n    blkcnt_t    st_blocks;\n};\n\n\n\n\nFile Types\n\n\n\n\nRegular file. All binary executable files conform to a format that allows the kernel to identify where to load a program\u2019s text and data.\n\n\nDirectory file. A file that contains the names of other files and pointers to information on these files. Any process that has read permission for a directory file can read the contents of the directory, but only the kernel can write directly to a directory file.\n\n\nBlock special file\n\n\nCharacter special file\n\n\nFIFO\n\n\nSocket\n\n\nSymbolic link\n\n\n\n\nThis program prints the type of file for each command-line argument.\n\n\n\n\nfiletype.c\n\n\n\n\nSet-User-ID and Set-Group-ID\n\n\nFile Access Permissions\n\n\n\n\nWhenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including the current directory, if it is implied. Read permission for a directory and execute permission for a directory mean different things. Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory when it is a component of a pathname that we are trying to access. [p100]\n\n\nWe cannot create a new file in a directory unless we have write permission and execute permission in the directory.\n\n\n\n\nOwnership of New Files and Directories\n\n\n\n\nThe user ID of a new file is set to the effective user ID of the process\n\n\nThe group ID of a new file can be the effective group ID of the process; or group ID of the directory in which the file is being created.\n\n\n\n\nFreeBSD 8.0 and Mac OS X 10.6.8 always copy the new file\u2019s group ID from the directory. \n\n\naccess\n and \nfaccessat\n Functions\n\n\n\n\n\nThese functions test accessibility based on the real user and group IDs.\n\n\nThe \nflag\n argument can be used to change the behavior of \nfaccessat\n. If the \nAT_EACCESS\n flag is set, the access checks are made using the effective user and group IDs.\n\n\n\n\naccess.c\n\n\n\n\numask\n Function\n\n\nThe Single UNIX Specification requires that the \numask\n command support a symbolic mode of operation. Unlike the octal format, the symbolic format specifies which permissions are to be allowed instead of which ones are to be denied.\n\n\n$ umask  # first print the current file mode creation mask\n002\n$ umask -S  # print the symbolic form\nu=rwx,g=rwx,o=rx\n$ umask 027  # print the symbolic form\n$ umask -S  # print the symbolic form\nu=rwx,g=rx,o=\n\n\n\n\nchmod\n, \nfchmod\n, and \nfchmodat\n Functions\n\n\n\n\n\nchmod\n automatically clears the following permission bits under the following conditions:\n\n\n\n\nSetting sticky bit on a regular file without superuser privileges (Solaris)\n\n\nIf the group ID of the new file does not equal either the effective group ID of the process or one of the process\u2019s supplementary group IDs and if the process does not have superuser privileges, then the set-group-ID bit is automatically turned off. On FreeBSD 8.0, Linux 3.2.0 and Mac OS X 10.6.8, if a process that does not have superuser privileges writes to a file, the set-user-ID and set-group-ID bits are automatically turned off.\n\n\n\n\nSticky Bit\n\n\nSticky Bit (\nS_ISVTX\n), or saved-text bit in the later versions of the UNIX System.\n\n\n\n\nOn file: only on a minority of systems\n\n\nOn directory: \n/tmp\n and \n/var/tmp\n\n\n\n\nchown\n, \nfchown\n, \nfchownat\n, and \nlchown\n Functions\n\n\n\n\n\n\n\nlchown\n and \nfchownat\n (with the \nAT_SYMLINK_NOFOLLOW\n flag set) change the owners of the symbolic link itself.\n\n\nfchown\n operates on a open file, it can\u2019t be used to change the ownership of a symbolic link.\n\n\n\n\nOnly the superuser can change the ownership of a file (FreeBSD 8.0, Linux 3.2.0, and Mac OS X 10.6.8)\n\n\nWhen \n_POSIX_CHOWN_RESTRICTED\n is in effect, a non-superuser can\u2019t change the user ID of your files; A nonsuperuser can change the group ID of files that he owns, but only to groups that he belongs to.\n\n\nFile Size\n\n\nThe \nst_size\n member of the stat structure contains the size of the file in bytes. This field is meaningful only for regular files, directories, and symbolic links.\n\n\nFreeBSD 8.0, Mac OS X 10.6.8, and Solaris 10 also define the file size for a pipe as the number of bytes that are available for reading from the pipe.\n\n\n\n\nFor a regular file, a file size of 0 is allowed. We\u2019ll get an end-of-file indication on the first read of the file. \n\n\nFor a directory, the file size is usually a multiple of a number, such as 16 or 512.\n\n\nFor a symbolic link, the file size is the number of bytes in the filename.\n\n\n\n\nMost contemporary UNIX systems provide two fields:\n\n\n\n\nst_blksize\n: preferred block size for I/O for the file\n\n\nst_blocks\n: actual number of 512-byte blocks that are allocated\n\n\n\n\nBe aware that different versions of the UNIX System use units other than 512-byte blocks for \nst_blocks\n. Use of this value is \nnonportable\n.\n\n\nHoles in a File\n\n\n$ ls -l core\n-rw-r--r-- 1 sar 8483248 Nov 18 12:18 core\n$ du -s core\n272 core\n\n\n\n\nFile Truncation\n\n\n\n\nThese two functions truncate an existing file to \nlength\n bytes. If the previous size of the file was greater than \nlength\n, the data beyond \nlength\n is no longer accessible. Otherwise, if the previous size was less than \nlength\n, the file size will increase and the data between the old end of file and the new end of file will read as 0 (a hole is probably created in the file).\n\n\nFile Systems\n\n\nMost UNIX file systems support \ncase-sensitive\n filenames. On Mac OS X, however, the HFS file system is \ncase-preserving\n with \ncase-insensitive\n comparisons.\n\n\n\n\n\n\nEvery i-node has a link count that contains the number of directory entries that point to it. Only when the link count (\nst_nlink\n) goes to 0 can the file be deleted.\n\n\nWith a symbolic link (file type \nS_IFLNK\n), the actual contents of the file (the data blocks) store the name of the file that the symbolic link points to.\n\n\nThe i-node contains all the information about the file: the file type, the file\u2019s access permission bits, the size of the file, pointers to the file\u2019s data blocks, and so on.\n\n\nOnly two items are stored in the directory entry: the filename and the i-node number. The data type for the i-node number is \nino_t\n.\n\n\n\n\nlink\n, \nlinkat\n, \nunlink\n, \nunlinkat\n, and \nremove\n Functions\n\n\n\n\n\nWhen a file is closed, the kernel first checks the count of the number of processes that have the file open. If this count has reached 0, the kernel then checks the link count; if it is 0, the file\u2019s contents are deleted.\n\n\nWhen the \nAT_REMOVEDIR\n flag is set, then the \nunlinkat\n function can be used to remove a directory, similar to using \nrmdir\n.\n\n\n\n\n\nrename\n and \nrenameat\n Functions\n\n\n\n\nSymbolic Links\n\n\nIt is possible to introduce loops into the file system by using symbolic links. Most functions that look up a pathname return an \nerrno\n of \nELOOP\n when this occurs.\n\n\nOn Linux, the \nftw\n and \nnftw\n functions record all directories seen and avoid processing a directory more than once, so they don\u2019t display this behavior.\n\n\n\n\nls -l\n\n\nls -F\n\n\n\n\n\n\n\nBecause the open function follows a symbolic link, we need a way to open the link itself and read the name in the link.\n\n\n\n\n\nThese functions combine the actions of \nopen\n, \nread\n, and \nclose\n.\n\n\nFile Times\n\n\n\n\n\n\n\n\nField\n\n\nDescription\n\n\nExample\n\n\nls(1) option\n\n\n\n\n\n\n\n\n\n\nst_atim\n\n\nlast-access time of file data\n\n\nread\n\n\n-u\n\n\n\n\n\n\nst_mtim\n\n\nlast-modification time of file data\n\n\nwrite\n\n\ndefault\n\n\n\n\n\n\nst_ctim\n\n\nlast-change time of i-node status\n\n\nchmod\n, \nchown\n\n\n-c\n\n\n\n\n\n\n\n\nThe system does not maintain the last-access time for an i-node. The functions \naccess\n and \nstat\n don\u2019t change any of the three times.\n\n\nfutimens\n, \nutimensat\n, and \nutimes\n Functions\n\n\n\n\n\nIn both functions, the first element of the times array argument contains the \naccess time\n, and the second element contains the \nmodification time\n.\n\n\n\n\n\nWe are unable to specify a value for the \nchanged-status time\n, \nst_ctim\n (the time the i-node was last changed), as this field is automatically updated when the \nutime\n function is called.\n\n\nmkdir\n, \nmkdirat\n, and \nrmdir\n Functions\n\n\n\n\n\nFor a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within the directory.\n\n\nSolaris 10 and Linux 3.2.0 also have the new directory inherit the set-group-ID bit from the parent directory. Files created in the new directory will then inherit the group ID of that directory. With Linux, the file system implementation determines whether this behavior is supported. For example, the ext2, ext3, and ext4 file systems allow this behavior to be controlled by an option to the mount(1) command.\n\n\nReading Directories\n\n\n\n\n\nThe \ndirent\n structure defined in \n is implementation dependent, with at least the following two members:\n\n\n    ino_t  d_ino;                 /* i-node number */\n    char   d_name[];              /* null-terminated filename */\n\n\n\n\nThe \nDIR\n structure is an internal structure used by these seven functions to maintain information about the directory being read. The purpose of the DIR structure is similar to that of the \nFILE\n structure maintained by the standard I/O library,\n\n\n\n\nftw8.c\n\n\n\n\nchdir\n, \nfchdir\n, and \ngetcwd\n Functions\n\n\n\n\n\n\nDevice Special Files\n\n\n\n\nEvery file system is known by its \nmajor\n and \nminor\n device numbers, which are encoded in the primitive system data type \ndev_t\n.\n\n\nWe can usually access the major and minor device numbers through two macros defined by most implementations: \nmajor\n and \nminor\n.\n\n\n\n\nOn Linux 3.2.0, \ndev_t\n is a 64-bit integer, only 12 bits are used for the major number and 20 bits are used for the minor number. Linux defines these macros in \nsys/sysmacros.h\n, which is included by \nsys/types.h\n.\n\n\nThe \nst_dev\n value for every filename on a system is the device number of the file system containing that filename and its corresponding i-node.\n\n\nOnly character special files and block special files have an \nst_rdev\n value. This value contains the device number for the actual device.\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nSection 4.21 on \nrmdir\n [p130]:\n\n\n\n\nIf the link count of the directory becomes 0 with this call, and if no other process has the directory open, then the space occupied by the directory is freed. If one or more processes have the directory open when the link count reaches 0, the last link is removed and the dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory.\n\n\n\n\nDoes \"link count\" here mean number of entries (except dot and dot-dot)? Otherwise, this contradicts  \"any leaf directory (a directory that does not contain any other directories) always has a link count of 2\" in section 4.14 on page 115.", 
            "title": "Chapter 4. Files and Directories"
        }, 
        {
            "location": "/apue/ch4/#chapter-4-files-and-directories", 
            "text": "This chapter centers on I/O for regular files.  restrict  keyword  Added in C99,  restrict  keyword is used to tell the compiler which pointer references can be optimized, by indicating that the object to which the pointer refers is accessed in the function only via that pointer. [p26]  stat ,  fstat ,  fstatat , and  lstat  Functions    stat : returns a structure of information about the named file  fstat : returns a structure of information about the given file descriptor  lstat : similar to  stat , returns information about the symbolic link, not the file referenced by the symbolic link  fstatat :  return the file statistics for a pathname relative to an open directory represented by the fd argument; the flag argument controls whether symbolic links are followed   The  buf  argument is a pointer to a  structure  that we must supply. The functions fill in the structure.  struct stat {\n    mode_t    st_mode;\n    ino_t    st_ino;\n    dev_t    st_dev;\n    dev_t    st_rdev;\n    nlink_t    st_nlink;\n    uid_t    st_uid;\n    gid_t    st_gid;\n    off_t    st_size;\n    struct timespec    st_atim;\n    struct timespec    st_mtim;\n    struct timespec    st_ctim;\n    blksize_t    st_blksize;\n    blkcnt_t    st_blocks;\n};  File Types   Regular file. All binary executable files conform to a format that allows the kernel to identify where to load a program\u2019s text and data.  Directory file. A file that contains the names of other files and pointers to information on these files. Any process that has read permission for a directory file can read the contents of the directory, but only the kernel can write directly to a directory file.  Block special file  Character special file  FIFO  Socket  Symbolic link   This program prints the type of file for each command-line argument.   filetype.c   Set-User-ID and Set-Group-ID  File Access Permissions   Whenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including the current directory, if it is implied. Read permission for a directory and execute permission for a directory mean different things. Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory when it is a component of a pathname that we are trying to access. [p100]  We cannot create a new file in a directory unless we have write permission and execute permission in the directory.   Ownership of New Files and Directories   The user ID of a new file is set to the effective user ID of the process  The group ID of a new file can be the effective group ID of the process; or group ID of the directory in which the file is being created.   FreeBSD 8.0 and Mac OS X 10.6.8 always copy the new file\u2019s group ID from the directory.   access  and  faccessat  Functions   These functions test accessibility based on the real user and group IDs.  The  flag  argument can be used to change the behavior of  faccessat . If the  AT_EACCESS  flag is set, the access checks are made using the effective user and group IDs.   access.c   umask  Function  The Single UNIX Specification requires that the  umask  command support a symbolic mode of operation. Unlike the octal format, the symbolic format specifies which permissions are to be allowed instead of which ones are to be denied.  $ umask  # first print the current file mode creation mask\n002\n$ umask -S  # print the symbolic form\nu=rwx,g=rwx,o=rx\n$ umask 027  # print the symbolic form\n$ umask -S  # print the symbolic form\nu=rwx,g=rx,o=  chmod ,  fchmod , and  fchmodat  Functions   chmod  automatically clears the following permission bits under the following conditions:   Setting sticky bit on a regular file without superuser privileges (Solaris)  If the group ID of the new file does not equal either the effective group ID of the process or one of the process\u2019s supplementary group IDs and if the process does not have superuser privileges, then the set-group-ID bit is automatically turned off. On FreeBSD 8.0, Linux 3.2.0 and Mac OS X 10.6.8, if a process that does not have superuser privileges writes to a file, the set-user-ID and set-group-ID bits are automatically turned off.   Sticky Bit  Sticky Bit ( S_ISVTX ), or saved-text bit in the later versions of the UNIX System.   On file: only on a minority of systems  On directory:  /tmp  and  /var/tmp   chown ,  fchown ,  fchownat , and  lchown  Functions    lchown  and  fchownat  (with the  AT_SYMLINK_NOFOLLOW  flag set) change the owners of the symbolic link itself.  fchown  operates on a open file, it can\u2019t be used to change the ownership of a symbolic link.   Only the superuser can change the ownership of a file (FreeBSD 8.0, Linux 3.2.0, and Mac OS X 10.6.8)  When  _POSIX_CHOWN_RESTRICTED  is in effect, a non-superuser can\u2019t change the user ID of your files; A nonsuperuser can change the group ID of files that he owns, but only to groups that he belongs to.  File Size  The  st_size  member of the stat structure contains the size of the file in bytes. This field is meaningful only for regular files, directories, and symbolic links.  FreeBSD 8.0, Mac OS X 10.6.8, and Solaris 10 also define the file size for a pipe as the number of bytes that are available for reading from the pipe.   For a regular file, a file size of 0 is allowed. We\u2019ll get an end-of-file indication on the first read of the file.   For a directory, the file size is usually a multiple of a number, such as 16 or 512.  For a symbolic link, the file size is the number of bytes in the filename.   Most contemporary UNIX systems provide two fields:   st_blksize : preferred block size for I/O for the file  st_blocks : actual number of 512-byte blocks that are allocated   Be aware that different versions of the UNIX System use units other than 512-byte blocks for  st_blocks . Use of this value is  nonportable .  Holes in a File  $ ls -l core\n-rw-r--r-- 1 sar 8483248 Nov 18 12:18 core\n$ du -s core\n272 core  File Truncation   These two functions truncate an existing file to  length  bytes. If the previous size of the file was greater than  length , the data beyond  length  is no longer accessible. Otherwise, if the previous size was less than  length , the file size will increase and the data between the old end of file and the new end of file will read as 0 (a hole is probably created in the file).  File Systems  Most UNIX file systems support  case-sensitive  filenames. On Mac OS X, however, the HFS file system is  case-preserving  with  case-insensitive  comparisons.    Every i-node has a link count that contains the number of directory entries that point to it. Only when the link count ( st_nlink ) goes to 0 can the file be deleted.  With a symbolic link (file type  S_IFLNK ), the actual contents of the file (the data blocks) store the name of the file that the symbolic link points to.  The i-node contains all the information about the file: the file type, the file\u2019s access permission bits, the size of the file, pointers to the file\u2019s data blocks, and so on.  Only two items are stored in the directory entry: the filename and the i-node number. The data type for the i-node number is  ino_t .   link ,  linkat ,  unlink ,  unlinkat , and  remove  Functions   When a file is closed, the kernel first checks the count of the number of processes that have the file open. If this count has reached 0, the kernel then checks the link count; if it is 0, the file\u2019s contents are deleted.  When the  AT_REMOVEDIR  flag is set, then the  unlinkat  function can be used to remove a directory, similar to using  rmdir .   rename  and  renameat  Functions   Symbolic Links  It is possible to introduce loops into the file system by using symbolic links. Most functions that look up a pathname return an  errno  of  ELOOP  when this occurs.  On Linux, the  ftw  and  nftw  functions record all directories seen and avoid processing a directory more than once, so they don\u2019t display this behavior.   ls -l  ls -F    Because the open function follows a symbolic link, we need a way to open the link itself and read the name in the link.   These functions combine the actions of  open ,  read , and  close .  File Times     Field  Description  Example  ls(1) option      st_atim  last-access time of file data  read  -u    st_mtim  last-modification time of file data  write  default    st_ctim  last-change time of i-node status  chmod ,  chown  -c     The system does not maintain the last-access time for an i-node. The functions  access  and  stat  don\u2019t change any of the three times.  futimens ,  utimensat , and  utimes  Functions   In both functions, the first element of the times array argument contains the  access time , and the second element contains the  modification time .   We are unable to specify a value for the  changed-status time ,  st_ctim  (the time the i-node was last changed), as this field is automatically updated when the  utime  function is called.  mkdir ,  mkdirat , and  rmdir  Functions   For a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within the directory.  Solaris 10 and Linux 3.2.0 also have the new directory inherit the set-group-ID bit from the parent directory. Files created in the new directory will then inherit the group ID of that directory. With Linux, the file system implementation determines whether this behavior is supported. For example, the ext2, ext3, and ext4 file systems allow this behavior to be controlled by an option to the mount(1) command.  Reading Directories   The  dirent  structure defined in   is implementation dependent, with at least the following two members:      ino_t  d_ino;                 /* i-node number */\n    char   d_name[];              /* null-terminated filename */  The  DIR  structure is an internal structure used by these seven functions to maintain information about the directory being read. The purpose of the DIR structure is similar to that of the  FILE  structure maintained by the standard I/O library,   ftw8.c   chdir ,  fchdir , and  getcwd  Functions    Device Special Files   Every file system is known by its  major  and  minor  device numbers, which are encoded in the primitive system data type  dev_t .  We can usually access the major and minor device numbers through two macros defined by most implementations:  major  and  minor .   On Linux 3.2.0,  dev_t  is a 64-bit integer, only 12 bits are used for the major number and 20 bits are used for the minor number. Linux defines these macros in  sys/sysmacros.h , which is included by  sys/types.h .  The  st_dev  value for every filename on a system is the device number of the file system containing that filename and its corresponding i-node.  Only character special files and block special files have an  st_rdev  value. This value contains the device number for the actual device.   Doubts and Solutions  Verbatim  Section 4.21 on  rmdir  [p130]:   If the link count of the directory becomes 0 with this call, and if no other process has the directory open, then the space occupied by the directory is freed. If one or more processes have the directory open when the link count reaches 0, the last link is removed and the dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory.   Does \"link count\" here mean number of entries (except dot and dot-dot)? Otherwise, this contradicts  \"any leaf directory (a directory that does not contain any other directories) always has a link count of 2\" in section 4.14 on page 115.", 
            "title": "Chapter 4. Files and Directories"
        }, 
        {
            "location": "/apue/ch5/", 
            "text": "Chapter 5. Standard I/O Library\n\n\nThe standard I/O library handles such details as buffer allocation and performing I/O in optimal-sized chunks.\n\n\nStreams and \nFILE\n Objects\n\n\nStandard I/O file streams can be used with both \nsingle-byte\n and \nmultibyte\n (\"wide\") character sets. A stream\u2019s orientation determines whether the characters that are read and written are single byte or multibyte. \n\n\n\n\nThis book deals only with \nbyte-oriented\n (single byte) streams.\n\n\nThis book refers to a pointer to a \nFILE\n object, the type \nFILE *\n, as a \nfile pointer\n.\n\n\n\n\nStandard Input, Standard Output, and Standard Error\n\n\nThree streams are predefined and automatically available to a process. They refer to file descriptors \nSTDIN_FILENO\n, \nSTDOUT_FILENO\n, and \nSTDERR_FILENO\n (defined in \nunistd.h\n) [p9]. These three standard I/O streams are referenced through the predefined file pointers \nstdin\n, \nstdout\n,and \nstderr\n(defined in \nstdio.h\n).\n\n\nBuffering\n\n\n\n\nFully buffered\n\n\nLine buffered\n\n\nUnbuffered\n\n\n\n\nMost implementations default to the following types of buffering:\n\n\n\n\nStandard error is always unbuffered.\n\n\nAll other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.\n\n\n\n\n\n\n\n\n\nsetbuf\n: \nbuf\n must point to a buffer of length \nBUFSIZ\n, a constant defined in \nstdio.h\n\n\nsetvbuf\n: type of buffering is specified with \n_IOFBF\n, \n_IOLBF\n, \n_IONBF\n.\n\n\n\n\nThe GNU C librarys use the value from the \nst_blksize\n member of the \nstat\n structure to determine the optimal standard I/O buffer size.\n\n\nThe \nfflush\n function causes any unwritten data for the stream to be passed to the kernel. If \nfp\n is \nNULL\n, \nfflush\n causes all output streams to be flushed.\n\n\nOpening a Stream\n\n\n\n\n\n\n\nfdopen\n function is often used with descriptors returned by the functions that create pipes and network communication channels, because these special types of files cannot be opened with the \nfopen\n function.\n\n\n\n\ntype\n argument has 15 values as specifed by ISO C:\n\n\n\n\n\n\n\n\ntype\n\n\nDescription\n\n\nopen\n(2) Flags\n\n\n\n\n\n\n\n\n\n\nr\n, \nrb\n\n\nopen for reading\n\n\nO_RDONLY\n\n\n\n\n\n\nw\n, \nwb\n\n\ntruncate to 0 length or create for writing\n\n\nO_WRONLY\nO_CREAT\nO_TRUNC\n\n\n\n\n\n\na\n, \nab\n\n\nappend; open for writing at end of file, or create for writing\n\n\nO_WRONLY\nO_CREAT\nO_APPEND\n\n\n\n\n\n\nr+\n, \nr+b\n, \nrb+\n\n\nopen for reading and writing\n\n\nO_RDWR\n\n\n\n\n\n\nw+\n, \nw+b\n, \nwb+\n\n\ntruncate to 0 length or create for reading and writing\n\n\nO_RDWR\nO_CREAT\nO_TRUNC\n\n\n\n\n\n\na+\n, \na+b\n, \nab+\n\n\nopen or create for reading and writing at end of file\n\n\nO_RDWR\nO_CREAT\nO_APPEND\n\n\n\n\n\n\n\n\nCharacter \nb\n allows the standard I/O system to differentiate between a text file and a binary file. The UNIX kernel doesn\u2019t differentiate between these types of files, thus character \nb\n has no effect.\n\n\n\n\nWrite\n: The \nfdopen\n function cannot truncate any file it opens for writing\n\n\nAppend\n: each write will take place at the then current end of file. If multiple processes open the same file with the standard I/O append mode, the data from each process will be correctly written to the file\n\n\nRead and write\n (\n+\n sign in type): Output cannot be directly followed by input without an intervening \nfflush\n, \nfseek\n, \nfsetpos\n, or \nrewind\n. Input cannot be directly followed by output without an intervening \nfseek\n, \nfsetpos\n, or \nrewind\n, or an input operation that encounters an end of file.\n\n\n\n\n\n\n\nAn open stream is closed by calling \nfclose\n:\n\n\n\n\nAny buffered output data is flushed before the file is closed\n\n\nAny input data that may be buffered is discarded\n\n\n\n\nWhen a process terminates normally, either by calling the exit function directly or by returning from the main function, all standard I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.\n\n\nReading and Writing a Stream\n\n\nUnformatted I/O:\n\n\n\n\nCharacter-at-a-time I/O\n\n\nLine-at-a-time I/O: \nfgets\n and \nfputs\n. Each line is terminated with a newline character.\n\n\nDirect I/O (binary I/O, object-at-a-time I/O, record-oriented I/O, or structure-oriented I/O): \nfread\n and \nfwrite\n. For each I/O operation, we read or write some number of objects, where each object is of a specified size\n\n\n\n\nInput Functions\n\n\n\n\n\n\n\nThe function \ngetchar\n is defined to be equivalent to \ngetc(stdin)\n. \n\n\ngetc\n can be implemented as a macro, whereas \nfgetc\n cannot be implemented as a macro.\n\n\nThese three functions return the next character as an \nunsigned char\n converted to an \nint\n. Thus, all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in \nstdio.h\n is required to be a negative value. Its value is often \u22121.\n\n\n\n\nThese functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either \nferror\n or \nfeof\n:\n\n\n\n\n\nIn most implementations, two flags are maintained for each stream in the \nFILE\n object:\n\n\n\n\nAn error flag\n\n\nAn end-of-file flag\n\n\n\n\nBoth flags are cleared by calling \nclearerr\n.\n\n\nPushback\n\n\nAfter reading from a stream, we can push back characters by calling \nungetc\n.\n\n\n\n\n\n\n\nThe characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing.\n\n\nThe character that is pushed back does not have to be the same character that was read.\n\n\nWhen characters are pushed back with \nungetc\n, they are not written back to the underlying file or device. Instead, they are kept incore in the standard I/O library\u2019s buffer for the stream. EOF cannot be pushed back.\n\n\nUsed for peeking characters.\n\n\n\n\nOutput Functions\n\n\n\n\n\n\n\nputchar(c)\n is equivalent to \nputc(c, stdout)\n\n\nputc\n can be implemented as a macro, whereas \nfputc\n cannot be implemented as a macro.\n\n\n\n\nLine-at-a-Time I/O\n\n\n\n\n\n\n\ngets\n function reads from standard input, whereas \nfgets\n reads from the specified stream.\n\n\nfgets\n: reads \nn - 1\n characters (including the newline) or partial line if longer than \nn - 1\n into the buffer, then the buffer is (always) null terminated.\n\n\ngets\n: should never be used. Without specifying buffer size, this may cause buffer to overflow if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory. \ngets\n is marked as an obsolescent interface in SUSv4 and has been omitted from the latest version of the ISO C standard\n\n\n\n\n\n\n\n\n\nfputs\n: writes the null-terminated string to the specified stream without writing the null byte\n\n\nputs\n: writes the null-terminated string to the standard output without writing the null byte, and then writes a newline character to the standard output. \nputs\n should be avoided being used to prevent having to remember whether it appends a newline.\n\n\n\n\nStandard I/O Efficiency\n\n\n\n\n\n\n\n\nFunction\n\n\nUser CPU (seconds)\n\n\nSystem CPU (seconds)\n\n\nClock time (seconds)\n\n\nBytes of program text\n\n\n\n\n\n\n\n\n\n\nbest time from Figure 3.6\n\n\n0.05\n\n\n0.29\n\n\n3.18\n\n\n\n\n\n\n\n\nfgets\n, \nfputs\n\n\n2.27\n\n\n0.30\n\n\n3.49\n\n\n143\n\n\n\n\n\n\ngetc\n, \nputc\n\n\n8.45\n\n\n0.29\n\n\n10.33\n\n\n114\n\n\n\n\n\n\nfgetc\n, \nfputc\n\n\n8.16\n\n\n0.40\n\n\n10.18\n\n\n114\n\n\n\n\n\n\nsingle byte time from Figure 3.6\n\n\n134.61\n\n\n249.94\n\n\n394.95\n\n\n\n\n\n\n\n\n\n\n\n\nOne advantage of using the standard I/O routines is that we don\u2019t have to worry about buffering or choosing the optimal I/O size.\n\n\nUsually, \ngetc\n and \nputc\n are implemented as macros, but in the GNU C library implementation the macro simply expands to a function call.\n\n\nThe line-at-a-time functions are implemented using \nmemccpy(3)\n. Often, the memccpy function is implemented in assembly language instead of C, for efficiency.\n\n\n\n\nBinary I/O\n\n\nIf doing binary I/O, we often want to read or write an entire structure at a time. There are problems with the previous functions:\n\n\n\n\ngetc\n, \nputc\n: we have to loop through the entire structure one byte a time\n\n\nfputs\n: stops writing when it hits a null byte\n\n\nfgets\n: won't work correctly on input if any data bytes are null or newlines\n\n\n\n\n\n\n\nThese functions have two common uses:\n\n\nRead or write a binary array (e.g write elements 2 through 5 of a floating-point array):\n\n\nfloat   data[10];\n\nif (fwrite(\ndata[2], sizeof(float), 4, fp) != 4)\n    err_sys(\nfwrite error\n);\n\n\n\n\nRead or write a structure:\n\n\nstruct {\n    short  count;\n    long   total;\n    char   name[NAMESIZE];\n} item;\n\nif (fwrite(\nitem, sizeof(item), 1, fp) != 1)\n    err_sys(\nfwrite error\n);\n\n\n\n\n\n\nfread\n: return value can be less than \nnobj\n if an error occurs or if the end of file is encountered\n\n\nfwrite\n: if the return value is less than the requested \nnobj\n, an error has occurred\n\n\n\n\nThese two functions won't work on different systems (sometimes even on the same system):\n\n\n\n\nThe offset of a member within a structure can differ between compilers and systems because of different \nalignment requirements\n. Even on a single system, the binary layout of a structure can differ, depending on compiler options. [p157]\n\n\nThe binary formats used to store multibyte integers and floating-point values differ among machine architectures\n\n\n\n\nPositioning a Stream\n\n\n\n\n\n\n\nftell\n: return file's position indicator (bytes from the beginning of the file)\n\n\nfseek\n:\n\n\nBinary file: \nwhence\n can be \nSEEK_SET\n, \nSEEK_CUR\n, and \nSEEK_END\n\n\nText file: \nwhence\n has to be \nSEEK_SET\n; \noffset\n can only be 0 (rewind the file to its beginning) or a value that was returned by \nftell\n for that file.\n\n\n\n\n\n\nrewind\n: set the stream to the beginning of the file\n\n\n\n\n\n\n\n\n\n\nFormatted I/O\n\n\nFormatted Output\n\n\n\n\n\n\n\nsprintf\n: automatically appends a null byte at the end of the array, but this null byte is not included in the return value. \nsprintf\n is possible to overflow the buffer.\n\n\nsnprintf\n: returns the number of characters that would have been written to the buffer had it been big enough. If \nsnprintf\n returns a positive value less than the buffer size n, then the output was not truncated.\n\n\n\n\nConversion specification\n\n\n%[flags][fldwidth][precision][lenmodifier]convtype\n\n\n\n\n\n\n\n\nFlag\n\n\n\n\n\n\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\u2019\n\n\n(apostrophe) format integer with thousands grouping characters\n\n\n\n\n\n\n-\n\n\nleft-justify the output in the field\n\n\n\n\n\n\n+\n\n\nalways display sign of a signed conversion\n\n\n\n\n\n\n(space)\n\n\nprefix by a space if no sign is generated\n\n\n\n\n\n\n#\n\n\nconvert using alternative form (include 0x prefix for hexadecimal format, for example)\n\n\n\n\n\n\n0\n\n\nprefix with leading zeros instead of padding with spaces\n\n\n\n\n\n\n\n\n\n\n\n\nfldwidth\n specifies a minimum field width for the conversion\n\n\n\n\nprecision\n specifies the minimum number of digits to appear for integer conversions, the minimum number of digits to appear to the right of the decimal point for floating-point conversions, or the maximum number of bytes for string conversions\n\n\n\n\nlenmodifier\n pecifies the size of the argument\n\n\n\n\n\n\n\n\nLength modifier\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhh\n\n\nsigned or unsigned \nchar\n\n\n\n\n\n\nh\n\n\nsigned or unsigned \nshort\n\n\n\n\n\n\nl\n\n\nsigned or unsigned \nlong\n or wide character\n\n\n\n\n\n\nll\n\n\nsigned or unsigned \nlong\n \nlong\n\n\n\n\n\n\nj\n\n\nintmax_t\n or \nuintmax_t\n\n\n\n\n\n\nz\n\n\nsize_t\n\n\n\n\n\n\nt\n\n\nptrdiff_t\n\n\n\n\n\n\nL\n\n\nlong double\n\n\n\n\n\n\n\n\n\n\n\n\nconvtype\n is required.\n\n\n\n\n\n\n\n\n\n\n\n\nConversion type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n,\ni\n\n\nsigned decimal\n\n\n\n\n\n\no\n\n\nunsigned octal\n\n\n\n\n\n\nu\n\n\nunsigned decimal\n\n\n\n\n\n\nx\n,\nX\n\n\nunsigned hexadecimal\n\n\n\n\n\n\nf\n,\nF\n\n\ndouble floating-point number\n\n\n\n\n\n\ne\n,\nE\n\n\ndouble floating-point number in exponential format\n\n\n\n\n\n\ng\n,\nG\n\n\ninterpreted as \nf\n, \nF\n, \ne\n, or \nE\n, depending on value converted\n\n\n\n\n\n\na\n,\nA\n\n\ndouble floating-point number in hexadecimal exponential format\n\n\n\n\n\n\nc\n\n\ncharacter (with \nl\n length modifier, wide character)\n\n\n\n\n\n\ns\n\n\nstring (with \nl\n length modifier, wide character string)\n\n\n\n\n\n\np\n\n\npointer to a void\n\n\n\n\n\n\nn\n\n\npointer to a signed integer into which is written the number of characters written so far\n\n\n\n\n\n\n%\n\n\na \n%\n character\n\n\n\n\n\n\nC\n\n\nwide character (XSI option, equivalent to \nlc\n)\n\n\n\n\n\n\nS\n\n\nwide character string (XSI option, equivalent to \nls\n)\n\n\n\n\n\n\n\n\nWith the normal conversion specification, conversions are applied to the arguments in the order they appear after the format argument. An alternative conversion specification syntax allows the arguments to be named explicitly with the sequence \n%n$\n representing the \nn\nth argument.\n\n\nThe following five variants of the printf family are similar to the previous five, but the variable argument list (\n...\n) is replaced with \narg\n.\n\n\n\n\n\nFormatted Output\n\n\n\n\n\nExcept for the conversion specifications and white space, other characters in the format have to match the input. If a character doesn\u2019t match, processing stops, leaving the remainder of the input unread.\n\n\nConversion specification\n\n\n%[*][fldwidth][m][lenmodifier]convtype\n\n\n\n\n\n\n*\n (leading asterisk) causes the result not stored in an argument\n\n\n\n\nm\n: \nassignment-allocation character\n, used with the \n%c\n, \n%s\n, and \n%[\n to force a memory  buffer to be allocated to hold the converted string. The caller is responsible for freeing the buffer.\n\n\n\n\n\n\nconvtype\n\n\n\n\n\n\n\n\n\n\n\n\nConversion type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n\n\nsigned decimal, base 10\n\n\n\n\n\n\ni\n\n\nsigned decimal, base determined by format of input\n\n\n\n\n\n\no\n\n\nunsigned octal (input optionally signed)\n\n\n\n\n\n\nu\n\n\nunsigned decimal, base 10 (input optionally signed)\n\n\n\n\n\n\nx\n,\nX\n\n\nunsigned hexadecimal (input optionally signed)\n\n\n\n\n\n\na\n,\nA\n,\ne\n,\nE\n,\nf\n,\nF\n,\ng\n,\nG\n\n\nfloating-point number\n\n\n\n\n\n\nc\n\n\ncharacter (with \nl\n length modifier, wide character)\n\n\n\n\n\n\ns\n\n\nstring (with \nl\n length modifier, wide character string)\n\n\n\n\n\n\n[\n\n\nmatches a sequence of listed characters, ending with \n]\n\n\n\n\n\n\n[\u02c6\n\n\nmatches all characters except the ones listed, ending with \n]\n\n\n\n\n\n\np\n\n\npointer to a void\n\n\n\n\n\n\nn\n\n\npointer to a signed integer into which is written the number of characters read so far\n\n\n\n\n\n\n%\n\n\na \n%\n character\n\n\n\n\n\n\nC\n\n\nwide character (XSI option, equivalent to \nlc\n)\n\n\n\n\n\n\nS\n\n\nwide character string (XSI option, equivalent to \nls\n)\n\n\n\n\n\n\n\n\nImplementation Details\n\n\n\n\n\nEach standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling \nfileno\n.\n\n\n\n\nFILE\n implementaion in GNU C.\n\n\nbuf.c\n (Figure 5.11): print buffering for various standard I/O streams\n\n\n\n\nResult on OS X 10.10:\n\n\n$ ./buf\nenter any character\n\none line to standard error\nstream = stdin, line buffered, buffer size = 4096\nstream = stdout, line buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n\n$ ./buf \n /etc/group \n std.out 2\n std.err\n$ cat std.out \nenter any character\nstream = stdin, fully buffered, buffer size = 4096\nstream = stdout, fully buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n$ cat std.err \none line to standard error\n\n\n\n\nTemporary Files\n\n\n\n\n\n\n\ntmpnam\n: generates a string that is a valid pathname that does not match any existing file. This function generates a different pathname each time it is called, up to \nTMP_MAX\n times. \n\n\nWhen \nptr\n is \nNULL\n: pathname is stored in a static area\n\n\nWhen \nptr\n is not \nNULL\n: it is assumed that it points to an array of at least \nL_tmpnam\n characters. The generated pathname is stored in this array, and \nptr\n is returned as the value of the function.\n\n\n\n\n\n\ntmpfile\n: creates a temporary binary file (type \nwb+\n) that is automatically removed when it is closed or on program termination.\n\n\n\n\n\n\n\n\n\nmkdtemp\n: creates a uniquely named directory\n\n\nmkstemp\n: creates a uniquely named regular file\n\n\ntemplate\n: a pathname whose last six characters are set to \nXXXXXX\n (\n/tmp/dirXXXXXX\n)\n\n\n\n\nUnlike \ntmpfile\n, the temporary file created by \nmkstemp\n is not removed automatically for us.\n\n\nThe \ntmpfile\n and \nmkstemp\n functions should be used instead of \ntmpnam\n. [p169]\n\n\nExample:\n\n\n\n\napue_stdio_mkstemp.c\n: the array variable is allocated on the stacl. For a pointer to a string literal, only the pointer itself resides on the stack; the (constant) string is stored in the read-only segment of the program.\n\n\n\n\nMemory Streams\n\n\nMemory streams\n are standard I/O streams for which there are no underlying files, although they are still accessed with \nFILE\n pointers. All I/O is done by transferring bytes to and from buffers in main memory.\n\n\n\n\n\n\n\nbuf\n: points to the beginning of the user-allocated buffer and the size argument specifies the size of the buffer in bytes. If the buf argument is null, then the fmemopen function allocates a buffer of \nsize\n bytes.\n\n\ntype\n: controls how the stream can be used [p171]\n\n\n\n\nNote:\n\n\n\n\nUnder append mode, the current file position is set to the first null byte in the buffer. If the buffer contains no null bytes, then the current position is set to one byte past the end of the buffer. Under non-append mode, the current position is set to the beginning of the buffer. Thus, memory streams aren\u2019t well suited for storing binary data (which might contain null bytes before the end of the data).\n\n\nIf the \nbuf\n argument is a null pointer, it makes no sense to open the stream for only reading or only writing. Because the buffer is allocated by \nfmemopen\n in this case, there is no way to find the buffer's address\n\n\nA null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call \nfclose\n, \nfflush\n, \nfseek\n, \nfseeko\n, or \nfsetpos\n.\n\n\n\n\nAlternatives to Standard I/O\n\n\nWhen we use the line-at-a-time functions, \nfgets\n and \nfputs\n, the data is usually copied twice: once between the kernel and the standard I/O buffer (when the corresponding read or write is issued) and again between the standard I/O buffer and our line buffer.\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nSection 5.4 on line buffering [p145]\n\n\n\n\nSecond, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed. The reason for the qualifier on (b) is that the requested data may already be in the buffer, which doesn\u2019t require data to be read from the kernel. Obviously, any input from an unbuffered stream, item (a), requires data to be obtained from the kernel.\n\n\n\n\nSection 5.8 Standard I/O Efficiency [p155]\n\n\n\n\nThe version using line-at-a-time I/O is almost twice as fast as the version using character-at-a-time I/O. If the fgets and fputs functions are implemented using getc and putc, then we would expect the timing to be similar to the getc version. Actually, we might expect the line-at-a-time version to take longer, since we would be adding the overhead of 200 million extra function calls to the existing 6 million ones.\n\n\n\n\nSection 5.14 on Memory Stream [p172]\n\n\n\n\nThird, a null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call fclose, fflush, fseek, fseeko, or fsetpos.", 
            "title": "Chapter 5. Standard I/O Library"
        }, 
        {
            "location": "/apue/ch5/#chapter-5-standard-io-library", 
            "text": "The standard I/O library handles such details as buffer allocation and performing I/O in optimal-sized chunks.  Streams and  FILE  Objects  Standard I/O file streams can be used with both  single-byte  and  multibyte  (\"wide\") character sets. A stream\u2019s orientation determines whether the characters that are read and written are single byte or multibyte.    This book deals only with  byte-oriented  (single byte) streams.  This book refers to a pointer to a  FILE  object, the type  FILE * , as a  file pointer .   Standard Input, Standard Output, and Standard Error  Three streams are predefined and automatically available to a process. They refer to file descriptors  STDIN_FILENO ,  STDOUT_FILENO , and  STDERR_FILENO  (defined in  unistd.h ) [p9]. These three standard I/O streams are referenced through the predefined file pointers  stdin ,  stdout ,and  stderr (defined in  stdio.h ).  Buffering   Fully buffered  Line buffered  Unbuffered   Most implementations default to the following types of buffering:   Standard error is always unbuffered.  All other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.     setbuf :  buf  must point to a buffer of length  BUFSIZ , a constant defined in  stdio.h  setvbuf : type of buffering is specified with  _IOFBF ,  _IOLBF ,  _IONBF .   The GNU C librarys use the value from the  st_blksize  member of the  stat  structure to determine the optimal standard I/O buffer size.  The  fflush  function causes any unwritten data for the stream to be passed to the kernel. If  fp  is  NULL ,  fflush  causes all output streams to be flushed.  Opening a Stream    fdopen  function is often used with descriptors returned by the functions that create pipes and network communication channels, because these special types of files cannot be opened with the  fopen  function.   type  argument has 15 values as specifed by ISO C:     type  Description  open (2) Flags      r ,  rb  open for reading  O_RDONLY    w ,  wb  truncate to 0 length or create for writing  O_WRONLY O_CREAT O_TRUNC    a ,  ab  append; open for writing at end of file, or create for writing  O_WRONLY O_CREAT O_APPEND    r+ ,  r+b ,  rb+  open for reading and writing  O_RDWR    w+ ,  w+b ,  wb+  truncate to 0 length or create for reading and writing  O_RDWR O_CREAT O_TRUNC    a+ ,  a+b ,  ab+  open or create for reading and writing at end of file  O_RDWR O_CREAT O_APPEND     Character  b  allows the standard I/O system to differentiate between a text file and a binary file. The UNIX kernel doesn\u2019t differentiate between these types of files, thus character  b  has no effect.   Write : The  fdopen  function cannot truncate any file it opens for writing  Append : each write will take place at the then current end of file. If multiple processes open the same file with the standard I/O append mode, the data from each process will be correctly written to the file  Read and write  ( +  sign in type): Output cannot be directly followed by input without an intervening  fflush ,  fseek ,  fsetpos , or  rewind . Input cannot be directly followed by output without an intervening  fseek ,  fsetpos , or  rewind , or an input operation that encounters an end of file.    An open stream is closed by calling  fclose :   Any buffered output data is flushed before the file is closed  Any input data that may be buffered is discarded   When a process terminates normally, either by calling the exit function directly or by returning from the main function, all standard I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.  Reading and Writing a Stream  Unformatted I/O:   Character-at-a-time I/O  Line-at-a-time I/O:  fgets  and  fputs . Each line is terminated with a newline character.  Direct I/O (binary I/O, object-at-a-time I/O, record-oriented I/O, or structure-oriented I/O):  fread  and  fwrite . For each I/O operation, we read or write some number of objects, where each object is of a specified size   Input Functions    The function  getchar  is defined to be equivalent to  getc(stdin) .   getc  can be implemented as a macro, whereas  fgetc  cannot be implemented as a macro.  These three functions return the next character as an  unsigned char  converted to an  int . Thus, all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in  stdio.h  is required to be a negative value. Its value is often \u22121.   These functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either  ferror  or  feof :   In most implementations, two flags are maintained for each stream in the  FILE  object:   An error flag  An end-of-file flag   Both flags are cleared by calling  clearerr .  Pushback  After reading from a stream, we can push back characters by calling  ungetc .    The characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing.  The character that is pushed back does not have to be the same character that was read.  When characters are pushed back with  ungetc , they are not written back to the underlying file or device. Instead, they are kept incore in the standard I/O library\u2019s buffer for the stream. EOF cannot be pushed back.  Used for peeking characters.   Output Functions    putchar(c)  is equivalent to  putc(c, stdout)  putc  can be implemented as a macro, whereas  fputc  cannot be implemented as a macro.   Line-at-a-Time I/O    gets  function reads from standard input, whereas  fgets  reads from the specified stream.  fgets : reads  n - 1  characters (including the newline) or partial line if longer than  n - 1  into the buffer, then the buffer is (always) null terminated.  gets : should never be used. Without specifying buffer size, this may cause buffer to overflow if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory.  gets  is marked as an obsolescent interface in SUSv4 and has been omitted from the latest version of the ISO C standard     fputs : writes the null-terminated string to the specified stream without writing the null byte  puts : writes the null-terminated string to the standard output without writing the null byte, and then writes a newline character to the standard output.  puts  should be avoided being used to prevent having to remember whether it appends a newline.   Standard I/O Efficiency     Function  User CPU (seconds)  System CPU (seconds)  Clock time (seconds)  Bytes of program text      best time from Figure 3.6  0.05  0.29  3.18     fgets ,  fputs  2.27  0.30  3.49  143    getc ,  putc  8.45  0.29  10.33  114    fgetc ,  fputc  8.16  0.40  10.18  114    single byte time from Figure 3.6  134.61  249.94  394.95       One advantage of using the standard I/O routines is that we don\u2019t have to worry about buffering or choosing the optimal I/O size.  Usually,  getc  and  putc  are implemented as macros, but in the GNU C library implementation the macro simply expands to a function call.  The line-at-a-time functions are implemented using  memccpy(3) . Often, the memccpy function is implemented in assembly language instead of C, for efficiency.   Binary I/O  If doing binary I/O, we often want to read or write an entire structure at a time. There are problems with the previous functions:   getc ,  putc : we have to loop through the entire structure one byte a time  fputs : stops writing when it hits a null byte  fgets : won't work correctly on input if any data bytes are null or newlines    These functions have two common uses:  Read or write a binary array (e.g write elements 2 through 5 of a floating-point array):  float   data[10];\n\nif (fwrite( data[2], sizeof(float), 4, fp) != 4)\n    err_sys( fwrite error );  Read or write a structure:  struct {\n    short  count;\n    long   total;\n    char   name[NAMESIZE];\n} item;\n\nif (fwrite( item, sizeof(item), 1, fp) != 1)\n    err_sys( fwrite error );   fread : return value can be less than  nobj  if an error occurs or if the end of file is encountered  fwrite : if the return value is less than the requested  nobj , an error has occurred   These two functions won't work on different systems (sometimes even on the same system):   The offset of a member within a structure can differ between compilers and systems because of different  alignment requirements . Even on a single system, the binary layout of a structure can differ, depending on compiler options. [p157]  The binary formats used to store multibyte integers and floating-point values differ among machine architectures   Positioning a Stream    ftell : return file's position indicator (bytes from the beginning of the file)  fseek :  Binary file:  whence  can be  SEEK_SET ,  SEEK_CUR , and  SEEK_END  Text file:  whence  has to be  SEEK_SET ;  offset  can only be 0 (rewind the file to its beginning) or a value that was returned by  ftell  for that file.    rewind : set the stream to the beginning of the file     Formatted I/O  Formatted Output    sprintf : automatically appends a null byte at the end of the array, but this null byte is not included in the return value.  sprintf  is possible to overflow the buffer.  snprintf : returns the number of characters that would have been written to the buffer had it been big enough. If  snprintf  returns a positive value less than the buffer size n, then the output was not truncated.   Conversion specification  %[flags][fldwidth][precision][lenmodifier]convtype    Flag     Flag  Description      \u2019  (apostrophe) format integer with thousands grouping characters    -  left-justify the output in the field    +  always display sign of a signed conversion    (space)  prefix by a space if no sign is generated    #  convert using alternative form (include 0x prefix for hexadecimal format, for example)    0  prefix with leading zeros instead of padding with spaces       fldwidth  specifies a minimum field width for the conversion   precision  specifies the minimum number of digits to appear for integer conversions, the minimum number of digits to appear to the right of the decimal point for floating-point conversions, or the maximum number of bytes for string conversions   lenmodifier  pecifies the size of the argument     Length modifier  Description      hh  signed or unsigned  char    h  signed or unsigned  short    l  signed or unsigned  long  or wide character    ll  signed or unsigned  long   long    j  intmax_t  or  uintmax_t    z  size_t    t  ptrdiff_t    L  long double       convtype  is required.       Conversion type  Description      d , i  signed decimal    o  unsigned octal    u  unsigned decimal    x , X  unsigned hexadecimal    f , F  double floating-point number    e , E  double floating-point number in exponential format    g , G  interpreted as  f ,  F ,  e , or  E , depending on value converted    a , A  double floating-point number in hexadecimal exponential format    c  character (with  l  length modifier, wide character)    s  string (with  l  length modifier, wide character string)    p  pointer to a void    n  pointer to a signed integer into which is written the number of characters written so far    %  a  %  character    C  wide character (XSI option, equivalent to  lc )    S  wide character string (XSI option, equivalent to  ls )     With the normal conversion specification, conversions are applied to the arguments in the order they appear after the format argument. An alternative conversion specification syntax allows the arguments to be named explicitly with the sequence  %n$  representing the  n th argument.  The following five variants of the printf family are similar to the previous five, but the variable argument list ( ... ) is replaced with  arg .   Formatted Output   Except for the conversion specifications and white space, other characters in the format have to match the input. If a character doesn\u2019t match, processing stops, leaving the remainder of the input unread.  Conversion specification  %[*][fldwidth][m][lenmodifier]convtype   *  (leading asterisk) causes the result not stored in an argument   m :  assignment-allocation character , used with the  %c ,  %s , and  %[  to force a memory  buffer to be allocated to hold the converted string. The caller is responsible for freeing the buffer.    convtype       Conversion type  Description      d  signed decimal, base 10    i  signed decimal, base determined by format of input    o  unsigned octal (input optionally signed)    u  unsigned decimal, base 10 (input optionally signed)    x , X  unsigned hexadecimal (input optionally signed)    a , A , e , E , f , F , g , G  floating-point number    c  character (with  l  length modifier, wide character)    s  string (with  l  length modifier, wide character string)    [  matches a sequence of listed characters, ending with  ]    [\u02c6  matches all characters except the ones listed, ending with  ]    p  pointer to a void    n  pointer to a signed integer into which is written the number of characters read so far    %  a  %  character    C  wide character (XSI option, equivalent to  lc )    S  wide character string (XSI option, equivalent to  ls )     Implementation Details   Each standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling  fileno .   FILE  implementaion in GNU C.  buf.c  (Figure 5.11): print buffering for various standard I/O streams   Result on OS X 10.10:  $ ./buf\nenter any character\n\none line to standard error\nstream = stdin, line buffered, buffer size = 4096\nstream = stdout, line buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n\n$ ./buf   /etc/group   std.out 2  std.err\n$ cat std.out \nenter any character\nstream = stdin, fully buffered, buffer size = 4096\nstream = stdout, fully buffered, buffer size = 4096\nstream = stderr, unbuffered, buffer size = 1\nstream = /etc/passwd, fully buffered, buffer size = 4096\n$ cat std.err \none line to standard error  Temporary Files    tmpnam : generates a string that is a valid pathname that does not match any existing file. This function generates a different pathname each time it is called, up to  TMP_MAX  times.   When  ptr  is  NULL : pathname is stored in a static area  When  ptr  is not  NULL : it is assumed that it points to an array of at least  L_tmpnam  characters. The generated pathname is stored in this array, and  ptr  is returned as the value of the function.    tmpfile : creates a temporary binary file (type  wb+ ) that is automatically removed when it is closed or on program termination.     mkdtemp : creates a uniquely named directory  mkstemp : creates a uniquely named regular file  template : a pathname whose last six characters are set to  XXXXXX  ( /tmp/dirXXXXXX )   Unlike  tmpfile , the temporary file created by  mkstemp  is not removed automatically for us.  The  tmpfile  and  mkstemp  functions should be used instead of  tmpnam . [p169]  Example:   apue_stdio_mkstemp.c : the array variable is allocated on the stacl. For a pointer to a string literal, only the pointer itself resides on the stack; the (constant) string is stored in the read-only segment of the program.   Memory Streams  Memory streams  are standard I/O streams for which there are no underlying files, although they are still accessed with  FILE  pointers. All I/O is done by transferring bytes to and from buffers in main memory.    buf : points to the beginning of the user-allocated buffer and the size argument specifies the size of the buffer in bytes. If the buf argument is null, then the fmemopen function allocates a buffer of  size  bytes.  type : controls how the stream can be used [p171]   Note:   Under append mode, the current file position is set to the first null byte in the buffer. If the buffer contains no null bytes, then the current position is set to one byte past the end of the buffer. Under non-append mode, the current position is set to the beginning of the buffer. Thus, memory streams aren\u2019t well suited for storing binary data (which might contain null bytes before the end of the data).  If the  buf  argument is a null pointer, it makes no sense to open the stream for only reading or only writing. Because the buffer is allocated by  fmemopen  in this case, there is no way to find the buffer's address  A null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call  fclose ,  fflush ,  fseek ,  fseeko , or  fsetpos .   Alternatives to Standard I/O  When we use the line-at-a-time functions,  fgets  and  fputs , the data is usually copied twice: once between the kernel and the standard I/O buffer (when the corresponding read or write is issued) and again between the standard I/O buffer and our line buffer.  Doubts and Solutions  Verbatim  Section 5.4 on line buffering [p145]   Second, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed. The reason for the qualifier on (b) is that the requested data may already be in the buffer, which doesn\u2019t require data to be read from the kernel. Obviously, any input from an unbuffered stream, item (a), requires data to be obtained from the kernel.   Section 5.8 Standard I/O Efficiency [p155]   The version using line-at-a-time I/O is almost twice as fast as the version using character-at-a-time I/O. If the fgets and fputs functions are implemented using getc and putc, then we would expect the timing to be similar to the getc version. Actually, we might expect the line-at-a-time version to take longer, since we would be adding the overhead of 200 million extra function calls to the existing 6 million ones.   Section 5.14 on Memory Stream [p172]   Third, a null byte is written at the current position in the stream whenever we increase the amount of data in the stream\u2019s buffer and call fclose, fflush, fseek, fseeko, or fsetpos.", 
            "title": "Chapter 5. Standard I/O Library"
        }, 
        {
            "location": "/apue/ch6/", 
            "text": "Chapter 6. System Data Files and Information\n\n\nThis chapter covers portable interfaces to data files, system identification functions and the time and date functions.\n\n\nPassword File\n\n\nThe UNIX System's password file, called the user database by POSIX.1, contains the following fields:\n\n\n\n\nHistorically, the password file has been stored in \n/etc/passwd\n and has been an ASCII file.\n\n\n\n\nroot\n has a user ID of 0 (superuser)\n\n\nThe encrypted password field contains a single character as a placeholder (\nx\n) \n\n\nSome fields can be empty\n\n\nThe shell field contains the user's login shell. The default value for an empty shell field is usually \n/bin/sh\n. Other executable that prevents a user from loggin in to a system:\n\n\n/dev/null\n\n\n/bin/false\n: exits with an unsuccessful (nonzero) status\n\n\n/bin/true\n: exits with a successful (zero) status\n\n\nnologin\n: prints a customizable error message and exits with a nonzero exit status\n\n\n\n\n\n\nnobody\n user name can be used to allow people to log in to a system, but with a user ID (65534) and group ID (65534) that provide no privileges.\n\n\nSome systems that provide the \nfinger(1)\n command support additional information in the comment field\n\n\n\n\nSome systems provide the \nvipw\n command to allow administrators to edit the password file.\n\n\n\n\n\n\n\ngetpwuid\n: used by the \nls(1)\n program to map the numerical user ID contained in an i-node into a user's login name.\n\n\ngetpwnam\n: used by the \nlogin(1)\n program when we enter our login name\n\n\n\n\nBoth functions return a pointer to a passwd structure that the functions fill in. This structure is usually a static variable within the function, so its contents are overwritten each time we call either of these functions.\n\n\n\n\n\n\n\ngetpwent\n: returns the next entry (a pointer to a structure that it has filled in, this structure is overwritten each time we call this function) in the password file.\n\n\nsetpwent\n: rewinds files\n\n\nendpwent\n: closes files\n\n\n\n\nExample:\n\n\n\n\ngetpwnam.c\n\n\n\n\nsetpwent\n at the beginning of this function is self-defense: we ensure that the files are rewound, in case the caller has already opened them by calling getpwent.\n\n\nShadow Passwords\n\n\nSystems store the encrypted password in another file, often called the \nshadow password file\n. Minimally, this file has to contain the user name and the encrypted password.\n\n\n\n\nThe shadow password file should not be readable by the world. Only a few programs need to access encrypted passwords, e.g. \nlogin(1)\n and \npasswd(1)\n, and these programs are often set-user-ID root. With shadow passwords, the regular password file, \n/etc/passwd\n, can be left readable by the world.", 
            "title": "Chapter 6. System Data Files and Information"
        }, 
        {
            "location": "/apue/ch6/#chapter-6-system-data-files-and-information", 
            "text": "This chapter covers portable interfaces to data files, system identification functions and the time and date functions.  Password File  The UNIX System's password file, called the user database by POSIX.1, contains the following fields:   Historically, the password file has been stored in  /etc/passwd  and has been an ASCII file.   root  has a user ID of 0 (superuser)  The encrypted password field contains a single character as a placeholder ( x )   Some fields can be empty  The shell field contains the user's login shell. The default value for an empty shell field is usually  /bin/sh . Other executable that prevents a user from loggin in to a system:  /dev/null  /bin/false : exits with an unsuccessful (nonzero) status  /bin/true : exits with a successful (zero) status  nologin : prints a customizable error message and exits with a nonzero exit status    nobody  user name can be used to allow people to log in to a system, but with a user ID (65534) and group ID (65534) that provide no privileges.  Some systems that provide the  finger(1)  command support additional information in the comment field   Some systems provide the  vipw  command to allow administrators to edit the password file.    getpwuid : used by the  ls(1)  program to map the numerical user ID contained in an i-node into a user's login name.  getpwnam : used by the  login(1)  program when we enter our login name   Both functions return a pointer to a passwd structure that the functions fill in. This structure is usually a static variable within the function, so its contents are overwritten each time we call either of these functions.    getpwent : returns the next entry (a pointer to a structure that it has filled in, this structure is overwritten each time we call this function) in the password file.  setpwent : rewinds files  endpwent : closes files   Example:   getpwnam.c   setpwent  at the beginning of this function is self-defense: we ensure that the files are rewound, in case the caller has already opened them by calling getpwent.  Shadow Passwords  Systems store the encrypted password in another file, often called the  shadow password file . Minimally, this file has to contain the user name and the encrypted password.   The shadow password file should not be readable by the world. Only a few programs need to access encrypted passwords, e.g.  login(1)  and  passwd(1) , and these programs are often set-user-ID root. With shadow passwords, the regular password file,  /etc/passwd , can be left readable by the world.", 
            "title": "Chapter 6. System Data Files and Information"
        }, 
        {
            "location": "/utlk/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nThis chapter gives an overview of major features of Linux, as well as Unix kernels. This book is based on \nLinux 2.6.11\n source code.\n\n\nLinux Versus Other Unix-Like Kernels\n\n\nSeveral differences between Linux and Unix implementations:\n\n\n\n\nKernel threading\n\n\nPreemptive kernel: Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode\n\n\nMultiprocessor support: Linux 2.6 supports symmetric multiprocessing (SMP)\n\n\nSTREAMS\n is not included in Linux\n\n\n\n\nThe Process/Kernel Model\n\n\n\n\nUsers processes\n\n\nKernel threads:\n\n\nrun in Kernel Mode;\n\n\nare non-interactive;\n\n\ncreated during system startup\n\n\n\n\n\n\nKernel routines can be activated in: \n\n\nsystem call;\n\n\nexception signaled by a process; \n\n\ninterrupt by a peripheral device;\n\n\nkernel thread executed\n\n\n\n\n\n\n\n\nProcess Implementation\n\n\nProcess descriptor\n contains registers:\n\n\n\n\nProgram counter (PC) registers\n\n\nStack pointer (SP) registers\n\n\nGeneral purpose registers\n\n\nFloating point registers\n\n\nProcessor control registers\n\n\nMemory management registers\n\n\n\n\nReentrant Kernels\n\n\nA \nkernel control\n path denotes the sequence of instructions executed by the kernel to handle a system call, an exception, or an interrupt.\n\n\nProcess Address Space\n\n\nSynchronization and Critical Regions\n\n\nSignals and Interprocess Communication\n\n\n\n\nUnix signals\n\n\nSystem V IPC: semaphores, message queues, and shared memory\n\n\n\n\nProcess Management\n\n\n\n\nfork()\n, \n_exit()\n, and \nexec()\n-like system calls\n\n\nwait4()\n\n\nProcess groups and login sessions\n\n\n\n\nMemory Management\n\n\n\n\nVirtual memory acts as a logical layer between the application memory requests and the hardware Memory Management Unit (MMU).\n\n\nKernel Memory Allocator: Linux\u2019s KMA uses a Slab allocator on top of a buddy system.\n\n\nProcess virtual address space\n\n\n\n\n\n\nDoubts and Solutions\n\n\nVerbatim\n\n\nChatper 1 on Linux Versus Other Unix-Like Kernels [p3]:\n\n\n\n\nLinux uses kernel threads in a very limited way to execute a few kernel functions periodically; however, they do not represent the basic execution context abstraction. \n\n\n\n\nSummary\n\n\nKernel Architecture\n\n\n\n\nThe Linux kernel, as with most Unix kernels, is \nmonolithic\n: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process. [p11]", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/utlk/ch1/#chapter-1-introduction", 
            "text": "This chapter gives an overview of major features of Linux, as well as Unix kernels. This book is based on  Linux 2.6.11  source code.  Linux Versus Other Unix-Like Kernels  Several differences between Linux and Unix implementations:   Kernel threading  Preemptive kernel: Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode  Multiprocessor support: Linux 2.6 supports symmetric multiprocessing (SMP)  STREAMS  is not included in Linux   The Process/Kernel Model   Users processes  Kernel threads:  run in Kernel Mode;  are non-interactive;  created during system startup    Kernel routines can be activated in:   system call;  exception signaled by a process;   interrupt by a peripheral device;  kernel thread executed     Process Implementation  Process descriptor  contains registers:   Program counter (PC) registers  Stack pointer (SP) registers  General purpose registers  Floating point registers  Processor control registers  Memory management registers   Reentrant Kernels  A  kernel control  path denotes the sequence of instructions executed by the kernel to handle a system call, an exception, or an interrupt.  Process Address Space  Synchronization and Critical Regions  Signals and Interprocess Communication   Unix signals  System V IPC: semaphores, message queues, and shared memory   Process Management   fork() ,  _exit() , and  exec() -like system calls  wait4()  Process groups and login sessions   Memory Management   Virtual memory acts as a logical layer between the application memory requests and the hardware Memory Management Unit (MMU).  Kernel Memory Allocator: Linux\u2019s KMA uses a Slab allocator on top of a buddy system.  Process virtual address space    Doubts and Solutions  Verbatim  Chatper 1 on Linux Versus Other Unix-Like Kernels [p3]:   Linux uses kernel threads in a very limited way to execute a few kernel functions periodically; however, they do not represent the basic execution context abstraction.    Summary  Kernel Architecture   The Linux kernel, as with most Unix kernels, is  monolithic : each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process. [p11]", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/utlk/ch2/", 
            "text": "Chapter 2. Memory Addressing\n\n\nThis chapter offers details in \nx86\n microprocessors address memory chips and how Linux uses the available addressing circuits.\n\n\nMemory Addresses\n\n\n\n\nLogical address\n\n\nLinear address\n (also known as \nvirtual address\n)\n\n\nPhysical address\n\n\n\n\nMemory Management Unit (MMU) transforms a logical address into a linear address, and the linear address into a physical address.\n\n\n\n\nMemory arbiter: read or write operations on a RAM chip must be performed serially.\n\n\nSegmentation in Hardware\n\n\nThe following sections focus on address translation when \nprotected mode\n is enabled, in Intel microprocessors starting with the 80286 model.\n\n\nSegment Selectors\n\n\nA logical address consists of:\n\n\n\n\nSegment Selector\n (segment identifier): 16-bit\n\n\nOffset: 32-bit\n\n\n\n\nSegmentation registers\n\n\nSegmentation Registers\n hold Segment Selectors.\n\n\n\n\ncs\n: code segment (program instructions); 2-bit field for CPU's Current Privilege Level (CPL), Linux uses only levels 0 and 3 for Kernel Mode and User Mode\n\n\nss\n: stack segment (current program stack)\n\n\nds\n: data segment (global and static data)\n\n\nes\n, \nfs\n, and \ngs\n: general purpose (arbitrary data)\n\n\n\n\nSegment Descriptors\n\n\nEach segment is represented by an 8-byte \nSegment Descriptor\n that describes the segment characteristics. Segment Descriptors are stored either in the \nGlobal Descriptor Table\n (GDT) or in the \nLocal Descriptor Table\n (LDT). The address and size of GDT and LDT are contained in \ngdtr\n and \nldtr\n control registers respectively.\n\n\n\n\nCode Segment Descriptor: included in GDT or LDT\n\n\nData Segment Descriptor: included in GDT or LDT\n\n\nTask State Segment Descriptor (TSSD): refers to a Task State Segment (TSS), a segment used to save the contents of the processor registers; included in GDT only\n\n\nLocal Descriptor Table Descriptor (LDTD): refers to a segment containing an LDT; included in GDT only\n\n\n\n\nFast Access to Segment Descriptors\n\n\nSegmentation registers store only the Segment Selector. The x86 process provides an additional nonprogrammable register for each of the six programmable segmentation registers to speed up the translation of logical addresses into linear addresses. Each nonprogrammable register contains the 8-byte Segment Descriptor.\n\n\nSegment Selector fields [p40]:\n\n\n\n\nindex\n: identifies the Segment Descriptor entry contained in GDT or LDT\n\n\nTI\n (Table Indicator): specifies whether the Segment Descriptor is included in the GDT (\nTI\n = 0) or in the LDT (\nTI\n = 1).\n\n\nRPL\n (Requestor Privilege Level):  specifies the \nCurrent Privilege Level\n (CPL) of the CPU when the corresponding Segment Selector is loaded into the \ncs\n register\n\n\n\n\nSegmentation Unit\n\n\nThe \nsegmentation unit\n performs the following operations to obtain the linear address:\n\n\n\n\n\n\nExamines the \nTI\n field of the Segment Selector to determine which Descriptor Table (GDT or LDT) stores the Segment Descriptor\n\n\nComputes the address of the Segment Descriptor from the \nindex\n field of the Segment Selector\n\n\nAdds the offset of the logical address to the \nBase\n field of the Segment Descriptor\n\n\n\n\nSegmentation in Linux\n\n\nAll Linux processes running in User Mode use the same pair of segments to address instructions and data. This is similar to processes running in Kernel Mode.\n\n\n\n\nuser code segment\n\n\nuser data segment\n\n\nkernel code segment\n\n\nkernel data segment\n\n\n\n\nSegment Selectors are defined by the macros:\n\n\n\n\n__USER_CS\n\n\n__USER_DS\n\n\n__KERNEL_CS\n\n\n__KERNEL_DS\n\n\n\n\nTo address the kernel code segment, for instance, the kernel just loads the value yielded by the \n__KERNEL_CS\n macro into the \ncs\n segmentation register.\n\n\nThe linear addresses associated with such segments all start at 0 and reach the addressing limit of 2\n32\n \u20131. This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses.\n\n\nCPL\n, \nRPL\n and registers\n\n\nThe Current Privilege Level (CPL) of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the \nRPL\n field of the Segment Selector stored in the \ncs\n register. [p42]\n\n\nWhenever the CPL is changed, some segmentation registers (e.g. \nds\n, \nss\n) must be correspondingly updated. [p42-43]\n\n\nImplicit Segment Selector\n\n\nOnly Offset component of its logical address is specified:\n\n\n\n\nss\n: kernel saves a pointer to an instruction or to a data structure\n\n\ncs\n: kernel invokes a function\n\n\nds\n: kernel data structure\n\n\nes\n: user data structure\n\n\n\n\nThe Linux GDT\n\n\nIn multiprocessor systems there is one GDT for every CPU [p43].\n\n\n\n\ncpu_gdt_table\n array: stores GDTs\n\n\ncpu_gdt_descr\n array: addresses and sizes of the GDTs\n\n\n\n\nEach GDT includes 18 segment descriptors and 14 null, unused, or reserved entries. Unused entries are inserted on purpose so that Segment Descriptors usually accessed together are kept in the same 32-byte line of the hardware cache.\n\n\n\n\nFour user and kernel code and data segments\n\n\nTask State Segment (TSS)\n\n\nDefault Local Descriptor Table(LDT), usually shared by all processes\n\n\nThree Thread-Local Storage (TLS) segments: allows multithreaded applications to make use of up to three segments containing data local to each thread. The \nset_thread_area()\n and \nget_thread_area()\n system calls, respectively, create and release a TLS segment for the executing process.\n\n\nThree segments related to Advanced Power Management (APM)\n\n\nFive segments related to Plug and Play (PnP) BIOS services\n\n\nA special TSS segment used by the kernel to handle \"Double fault\" exceptions\n\n\n\n\nThe Linux LDT\n\n\nMost Linux User Mode applications do not make use of a Local Descriptor Table. The kernel defines a default LDT to be shared by most processes. It has five entries but only two are used by the kernel: a \ncall gate\n for \niBCS\n executables, and a call gate for Solaris/x86 executables.\n\n\nIn some cases, processes may require to set up their own LDT, such as applications (such as Wine) that execute segment-oriented Microsoft Windows applications. The \nmodify_ldt()\n system call allows a process to do this.\n\n\nPaging in Hardware\n\n\nThe paging unit translates linear addresses into physical ones. Its key task is to check the requested access type against the access rights of the linear address, and generates a Page Fault exception if memory access is not valid.\n\n\n\n\nPages\n: grouped fixed-length intervals of linear addresses; contiguous linear addresses within a page are mapped into contiguous physical addresses. The term \"page\" to refer both to a set of linear addresses and to the data contained in this group of addresses.\n\n\nPage frames\n (or \nphysical pages\n): RAM partitions from the perspective of the paging unit. Each page frame (storage area) contains a page (block of data), thus the length of a page frame coincides with that of a page.\n\n\nPage table\n: data structures (in main memory) that map linear to physical addresses\n\n\n\n\nRegular Paging\n\n\nThe x86 processors support paging; it is enabled by setting the \nPG\n flag of a control register named \ncr0\n.\n\n\n\n\nDoubts and Solutions\n\n\nSegmentation in Linux [p41]\n\n\n\n\nHowever, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons:", 
            "title": "Chapter 2. Memory Addressing"
        }, 
        {
            "location": "/utlk/ch2/#chapter-2-memory-addressing", 
            "text": "This chapter offers details in  x86  microprocessors address memory chips and how Linux uses the available addressing circuits.  Memory Addresses   Logical address  Linear address  (also known as  virtual address )  Physical address   Memory Management Unit (MMU) transforms a logical address into a linear address, and the linear address into a physical address.   Memory arbiter: read or write operations on a RAM chip must be performed serially.  Segmentation in Hardware  The following sections focus on address translation when  protected mode  is enabled, in Intel microprocessors starting with the 80286 model.  Segment Selectors  A logical address consists of:   Segment Selector  (segment identifier): 16-bit  Offset: 32-bit   Segmentation registers  Segmentation Registers  hold Segment Selectors.   cs : code segment (program instructions); 2-bit field for CPU's Current Privilege Level (CPL), Linux uses only levels 0 and 3 for Kernel Mode and User Mode  ss : stack segment (current program stack)  ds : data segment (global and static data)  es ,  fs , and  gs : general purpose (arbitrary data)   Segment Descriptors  Each segment is represented by an 8-byte  Segment Descriptor  that describes the segment characteristics. Segment Descriptors are stored either in the  Global Descriptor Table  (GDT) or in the  Local Descriptor Table  (LDT). The address and size of GDT and LDT are contained in  gdtr  and  ldtr  control registers respectively.   Code Segment Descriptor: included in GDT or LDT  Data Segment Descriptor: included in GDT or LDT  Task State Segment Descriptor (TSSD): refers to a Task State Segment (TSS), a segment used to save the contents of the processor registers; included in GDT only  Local Descriptor Table Descriptor (LDTD): refers to a segment containing an LDT; included in GDT only   Fast Access to Segment Descriptors  Segmentation registers store only the Segment Selector. The x86 process provides an additional nonprogrammable register for each of the six programmable segmentation registers to speed up the translation of logical addresses into linear addresses. Each nonprogrammable register contains the 8-byte Segment Descriptor.  Segment Selector fields [p40]:   index : identifies the Segment Descriptor entry contained in GDT or LDT  TI  (Table Indicator): specifies whether the Segment Descriptor is included in the GDT ( TI  = 0) or in the LDT ( TI  = 1).  RPL  (Requestor Privilege Level):  specifies the  Current Privilege Level  (CPL) of the CPU when the corresponding Segment Selector is loaded into the  cs  register   Segmentation Unit  The  segmentation unit  performs the following operations to obtain the linear address:    Examines the  TI  field of the Segment Selector to determine which Descriptor Table (GDT or LDT) stores the Segment Descriptor  Computes the address of the Segment Descriptor from the  index  field of the Segment Selector  Adds the offset of the logical address to the  Base  field of the Segment Descriptor   Segmentation in Linux  All Linux processes running in User Mode use the same pair of segments to address instructions and data. This is similar to processes running in Kernel Mode.   user code segment  user data segment  kernel code segment  kernel data segment   Segment Selectors are defined by the macros:   __USER_CS  __USER_DS  __KERNEL_CS  __KERNEL_DS   To address the kernel code segment, for instance, the kernel just loads the value yielded by the  __KERNEL_CS  macro into the  cs  segmentation register.  The linear addresses associated with such segments all start at 0 and reach the addressing limit of 2 32  \u20131. This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses.  CPL ,  RPL  and registers  The Current Privilege Level (CPL) of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the  RPL  field of the Segment Selector stored in the  cs  register. [p42]  Whenever the CPL is changed, some segmentation registers (e.g.  ds ,  ss ) must be correspondingly updated. [p42-43]  Implicit Segment Selector  Only Offset component of its logical address is specified:   ss : kernel saves a pointer to an instruction or to a data structure  cs : kernel invokes a function  ds : kernel data structure  es : user data structure   The Linux GDT  In multiprocessor systems there is one GDT for every CPU [p43].   cpu_gdt_table  array: stores GDTs  cpu_gdt_descr  array: addresses and sizes of the GDTs   Each GDT includes 18 segment descriptors and 14 null, unused, or reserved entries. Unused entries are inserted on purpose so that Segment Descriptors usually accessed together are kept in the same 32-byte line of the hardware cache.   Four user and kernel code and data segments  Task State Segment (TSS)  Default Local Descriptor Table(LDT), usually shared by all processes  Three Thread-Local Storage (TLS) segments: allows multithreaded applications to make use of up to three segments containing data local to each thread. The  set_thread_area()  and  get_thread_area()  system calls, respectively, create and release a TLS segment for the executing process.  Three segments related to Advanced Power Management (APM)  Five segments related to Plug and Play (PnP) BIOS services  A special TSS segment used by the kernel to handle \"Double fault\" exceptions   The Linux LDT  Most Linux User Mode applications do not make use of a Local Descriptor Table. The kernel defines a default LDT to be shared by most processes. It has five entries but only two are used by the kernel: a  call gate  for  iBCS  executables, and a call gate for Solaris/x86 executables.  In some cases, processes may require to set up their own LDT, such as applications (such as Wine) that execute segment-oriented Microsoft Windows applications. The  modify_ldt()  system call allows a process to do this.  Paging in Hardware  The paging unit translates linear addresses into physical ones. Its key task is to check the requested access type against the access rights of the linear address, and generates a Page Fault exception if memory access is not valid.   Pages : grouped fixed-length intervals of linear addresses; contiguous linear addresses within a page are mapped into contiguous physical addresses. The term \"page\" to refer both to a set of linear addresses and to the data contained in this group of addresses.  Page frames  (or  physical pages ): RAM partitions from the perspective of the paging unit. Each page frame (storage area) contains a page (block of data), thus the length of a page frame coincides with that of a page.  Page table : data structures (in main memory) that map linear to physical addresses   Regular Paging  The x86 processors support paging; it is enabled by setting the  PG  flag of a control register named  cr0 .   Doubts and Solutions  Segmentation in Linux [p41]   However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons:", 
            "title": "Chapter 2. Memory Addressing"
        }, 
        {
            "location": "/unp/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nIntroduction\n\n\nThe \nclient\n and \nserver\n organization is used by most network-awared applications. Some complex applications also require \nasynchronous callback\n communication, where the server initiates a message to the client.\n\n\nA Simple Daytime Client\n\n\n\n\ndaytimetcpcli.c\n\n\n\n\n\n\n\nCreate TCP socket\n\n\nThe \nsocket\n function creates an Internet (\nAF_INET\n) stream (\nSOCK_STREAM\n) socket, which is a fancy name for a TCP socket. The function returns a small integer descriptor to identify the socket.\n\n\nSpecify server's IP address and port\n\n\nThe IP address (\nsin_addr\n) and port number (\nsin_port\n) fields in the Internet socket address structure (\nsockaddr_in\n) must be in specific formats:\n\n\n\n\nhtons\n (host to network short): converts the binary port number\n\n\ninet_pton\n (presentation to numeric): convert the ASCII command-line argument (such as \n206.62.226.35\n when we ran this example) into the proper format.\n\n\n\n\nbzero\n is not an ANSI C function, but is used in this book instead of the ANSI C \nmemset\n function, because \nbzero\n is easier to remember (with only two arguments) than \nmemset\n (with three arguments).\n\n\nEstablish connection with server\n\n\n\n\nconnect\n\n\n\n\nIn the \nunp.h\n header, \nSA\n is defined to be \nstruct sockaddr\n, a generic socket address structure.\n\n\nRead and display server's reply\n\n\nWe must be careful when using TCP because it is a \nbyte-stream\n protocol with no record boundaries. Since we cannot assume that the server's reply will be returned by a single \nread\n, we always need to code the \nread\n in a loop when reading from a TCP socket.\n\n\nTerminate program\n\n\nexit\n terminates the program. Unix always closes all open descriptors when a process terminates.\n\n\nProtocol Independence\n\n\nThe above program is protocol-depdent on IPv4.\n\n\nIt is better to make a program protocol-independent by using the \ngetaddrinfo\n function.\n\n\nError Handling: Wrapper Functions\n\n\nWe can shorten our programs by defining a \nwrapper function\n that performs the actual function call, tests the return value, and terminates on an error.\n\n\nsockfd = Socket(AF_INET, SOCK_STREAM, 0);\n\n\n\n\nWith careful C coding, we could use macros instead of functions, providing a little run-time efficiency, but these wrapper functions are rarely the performance bottleneck of a program. This book uses these wrapper functions unless otherwise explicit error needs handling.\n\n\nUnix \nerrno\n Value\n\n\nThe value of \nerrno\n is set by a function only if an error occurs. All of the positive error values are constants with all-uppercase names beginning with \"E,\" and are normally defined in the \nsys/errno.h\n header. No error has a value of 0.\n\n\nStoring errno in a global variable does not work with multiple threads that share all global variables.\n\n\nA Simple Daytime Server\n\n\n\n\ndaytimetcpsrv.c\n\n\n\n\n\n\n\nCreate a TCP socket\n\n\nIdentical to the client code.\n\n\nBind server's well-known port to socket\n\n\n\n\nbind\n: the server's well-known port (13) is bound to the socket by calling \nbind\n\n\nINADDR_ANY\n allows the server to accept a client connection on any interface\n\n\n\n\nConvert socket to listening socket\n\n\n\n\nlisten\n: converts the socket into a listening socket, on which incoming connections from clients will be accepted by the kernel\n\n\nlistenfd\n in the code is called a \nlistening descriptor\n\n\n\n\nAccept client connection, send reply\n\n\n\n\naccept\n\n\nconnfd\n in the code is called a \nconnected descriptor\n for communication with the client. A new descriptor is returned by accept for each client that connects to our server.\n\n\n\n\nThis book uses this code style for infinite loop:\n\n\nfor ( ; ; ) {\n    // . . .\n}\n\n\n\n\nsnprintf\n function\n\n\n\n\nsnprintf\n instead of \nsprintf\n\n\n\n\nSimilarly:\n\n\n\n\nfgets\n instead of \ngets\n\n\nstrncat\n or \nstrlcat\n instead of \nstrcat\n\n\nstrncpy\n or \nstrlcpy\n instead of a \nstrcpy\n\n\n\n\nTerminate connection\n\n\nclose\n initiates the normal TCP connection termination sequence: a FIN is sent in each direction and each FIN is acknowledged by the other end.\n\n\nThe server implemented in the above server code is:\n\n\n\n\nProtocol-dependent on IPv4\n\n\nHandles only one client at a time. If multiple client connections arrive at about the same time, the kernel queues them, up to some limit, and returns them to \naccept\n one at a time.\n\n\nCalled an \niterative server\n. A \nconcurrent server\n handles multiple clients at the same time.\n\n\n\n\nOSI Model\n\n\nSome terms mentioned:\n\n\n\n\nRaw socket\n: it is possible for an application to bypass the transport layer and use IPv4 or IPv6 directly\n\n\nXTI\n\n\n\n\nSockets provide the interface from the upper three layers of the OSI model into the transport layer:\n\n\n\n\nThe upper three layers handle all the details of the application. The lower four layers know little about the application, but handle all the communication details\n\n\nThe upper three layers form what is called a \nuser process\n while the lower four layers are normally provided as part of the operating system (OS) kernel\n\n\n\n\nBSD Networking History\n\n\nLinux does not fit into the Berkeley-derived classification: Its networking code and sockets API were developed from scratch.\n\n\nUnix Standards\n\n\nBackground on POSIX\n\n\n\n\nPOSIX: Portable Operating System Interface, developed by IEEE and adopted as standards by ISO and IEC (ISO/IEC)\n\n\n\n\nBackground on The Open Group\n\n\n\n\nSingle UNIX Specification\n\n\n\n\nInternet Engineering Task Force (IETF)\n\n\n64-Bit Architectures\n\n\n\n\nILP32\n: integers (I), long integers (L), and pointers (P) occupy 32 bits.\n\n\nLP64\n:only long integers (L) and pointers (P) require 64 bits.\n\n\n\n\nFrom a programming perspective, the LP64 model means we cannot assume that a pointer can be stored in an integer. We must also consider the effect of the LP64 model on existing APIs\n\n\nOn a 32-bit system, \nsize_t\n is a 32-bit value, but on a 64-bit system, it must be a 64-bit value, to take advantage of the larger addressing model. This means a 64-bit system will probably contain a typedef of \nsize_t\n to be an unsigned long.", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/unp/ch1/#chapter-1-introduction", 
            "text": "Introduction  The  client  and  server  organization is used by most network-awared applications. Some complex applications also require  asynchronous callback  communication, where the server initiates a message to the client.  A Simple Daytime Client   daytimetcpcli.c    Create TCP socket  The  socket  function creates an Internet ( AF_INET ) stream ( SOCK_STREAM ) socket, which is a fancy name for a TCP socket. The function returns a small integer descriptor to identify the socket.  Specify server's IP address and port  The IP address ( sin_addr ) and port number ( sin_port ) fields in the Internet socket address structure ( sockaddr_in ) must be in specific formats:   htons  (host to network short): converts the binary port number  inet_pton  (presentation to numeric): convert the ASCII command-line argument (such as  206.62.226.35  when we ran this example) into the proper format.   bzero  is not an ANSI C function, but is used in this book instead of the ANSI C  memset  function, because  bzero  is easier to remember (with only two arguments) than  memset  (with three arguments).  Establish connection with server   connect   In the  unp.h  header,  SA  is defined to be  struct sockaddr , a generic socket address structure.  Read and display server's reply  We must be careful when using TCP because it is a  byte-stream  protocol with no record boundaries. Since we cannot assume that the server's reply will be returned by a single  read , we always need to code the  read  in a loop when reading from a TCP socket.  Terminate program  exit  terminates the program. Unix always closes all open descriptors when a process terminates.  Protocol Independence  The above program is protocol-depdent on IPv4.  It is better to make a program protocol-independent by using the  getaddrinfo  function.  Error Handling: Wrapper Functions  We can shorten our programs by defining a  wrapper function  that performs the actual function call, tests the return value, and terminates on an error.  sockfd = Socket(AF_INET, SOCK_STREAM, 0);  With careful C coding, we could use macros instead of functions, providing a little run-time efficiency, but these wrapper functions are rarely the performance bottleneck of a program. This book uses these wrapper functions unless otherwise explicit error needs handling.  Unix  errno  Value  The value of  errno  is set by a function only if an error occurs. All of the positive error values are constants with all-uppercase names beginning with \"E,\" and are normally defined in the  sys/errno.h  header. No error has a value of 0.  Storing errno in a global variable does not work with multiple threads that share all global variables.  A Simple Daytime Server   daytimetcpsrv.c    Create a TCP socket  Identical to the client code.  Bind server's well-known port to socket   bind : the server's well-known port (13) is bound to the socket by calling  bind  INADDR_ANY  allows the server to accept a client connection on any interface   Convert socket to listening socket   listen : converts the socket into a listening socket, on which incoming connections from clients will be accepted by the kernel  listenfd  in the code is called a  listening descriptor   Accept client connection, send reply   accept  connfd  in the code is called a  connected descriptor  for communication with the client. A new descriptor is returned by accept for each client that connects to our server.   This book uses this code style for infinite loop:  for ( ; ; ) {\n    // . . .\n}  snprintf  function   snprintf  instead of  sprintf   Similarly:   fgets  instead of  gets  strncat  or  strlcat  instead of  strcat  strncpy  or  strlcpy  instead of a  strcpy   Terminate connection  close  initiates the normal TCP connection termination sequence: a FIN is sent in each direction and each FIN is acknowledged by the other end.  The server implemented in the above server code is:   Protocol-dependent on IPv4  Handles only one client at a time. If multiple client connections arrive at about the same time, the kernel queues them, up to some limit, and returns them to  accept  one at a time.  Called an  iterative server . A  concurrent server  handles multiple clients at the same time.   OSI Model  Some terms mentioned:   Raw socket : it is possible for an application to bypass the transport layer and use IPv4 or IPv6 directly  XTI   Sockets provide the interface from the upper three layers of the OSI model into the transport layer:   The upper three layers handle all the details of the application. The lower four layers know little about the application, but handle all the communication details  The upper three layers form what is called a  user process  while the lower four layers are normally provided as part of the operating system (OS) kernel   BSD Networking History  Linux does not fit into the Berkeley-derived classification: Its networking code and sockets API were developed from scratch.  Unix Standards  Background on POSIX   POSIX: Portable Operating System Interface, developed by IEEE and adopted as standards by ISO and IEC (ISO/IEC)   Background on The Open Group   Single UNIX Specification   Internet Engineering Task Force (IETF)  64-Bit Architectures   ILP32 : integers (I), long integers (L), and pointers (P) occupy 32 bits.  LP64 :only long integers (L) and pointers (P) require 64 bits.   From a programming perspective, the LP64 model means we cannot assume that a pointer can be stored in an integer. We must also consider the effect of the LP64 model on existing APIs  On a 32-bit system,  size_t  is a 32-bit value, but on a 64-bit system, it must be a 64-bit value, to take advantage of the larger addressing model. This means a 64-bit system will probably contain a typedef of  size_t  to be an unsigned long.", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/unp/ch2/", 
            "text": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP\n\n\nIntroduction\n\n\nThis chapter focuses on the transport layer: TCP, UDP, and Stream Control Transmission Protocol (SCTP). UDP is a simple, unreliable datagram protocol, while TCP is a sophisticated, reliable byte-stream protocol. SCTP is similar to TCP as a reliable transport protocol, but it also provides message boundaries, transport-level support for multihoming, and a way to minimize head-of-line blocking.\n\n\nThe Big Picture\n\n\nOverview of TCP/IP protocols:\n\n\n\n\n\n\n\n\nProtocol\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIPv4\n\n\nInternet Protocol version 4. IPv4 uses 32-bit addresses and provides packet delivery service for TCP, UDP, SCTP, ICMP, and IGMP.\n\n\n\n\n\n\nIPv6\n\n\nInternet Protocol version 6. IPv6 uses 128-bit addresses.\n\n\n\n\n\n\nTCP\n\n\nTransmission Control Protocol. TCP is a connection-oriented protocol that provides a reliable, full-duplex byte stream to its users\n\n\n\n\n\n\nUDP\n\n\nUser Datagram Protocol. UDP is a connectionless protocol, and UDP sockets are an example of datagram sockets.\n\n\n\n\n\n\nSCTP\n\n\nStream Control Transmission Protocol. SCTP is a connection-oriented protocol that provides a reliable full-duplex association\n\n\n\n\n\n\nICMP\n\n\nInternet Control Message Protocol. ICMP handles error and control information between routers and hosts.\n\n\n\n\n\n\nIGMP\n\n\nInternet Group Management Protocol. IGMP is used with multicasting.\n\n\n\n\n\n\nARP\n\n\nAddress Resolution Protocol. ARP maps an IPv4 address into a hardware address (such as an Ethernet address). ARP is normally used on broadcast networks such as Ethernet, \ntoken ring\n, and \nFDDI\n, and is not needed on point-to-point networks.\n\n\n\n\n\n\nRARP\n\n\nReverse Address Resolution Protocol. RARP maps a hardware address into an IPv4 address. It is sometimes used when a diskless node is booting.\n\n\n\n\n\n\nICMPv6\n\n\nInternet Control Message Protocol version 6. ICMPv6 combines the functionality of ICMPv4, IGMP, and ARP.\n\n\n\n\n\n\nBPF\n\n\nBSD packet filter\n. This interface provides access to the datalink layer. It is normally found on Berkeley-derived kernels.\n\n\n\n\n\n\nDLPI\n\n\nDatalink provider interface\n.\n\n\n\n\n\n\n\n\nUser Datagram Protocol (UDP)\n\n\n\n\nLack of reliability\n\n\nEach UDP datagram has a length\n\n\nConnectionless\n service\n\n\n\n\nTransmission Control Protocol (TCP)\n\n\n\n\nConnection\n: TCP provides connections between clients and servers. A TCP client establishes a connection with a server, exchanges data across the connection, and then terminates the connection.\n\n\nReliability\n: TCP requires acknowledgment when sending data. If an acknowledgment is not received, TCP automatically retransmits the data and waits a longer amount of time.\n\n\nRound-trip time\n (RTT): TCP estimates RTT between a client and server dynamically so that it knows how long to wait for an acknowledgment.\n\n\nSequencing\n: TCP associates a sequence number with every byte (\nsegment\n, unit of data that TCP passes to IP.) it sends. TCP reorders out-of-order segments and discards duplicate segments.\n\n\nFlow control\n\n\nFull-duplex\n: an application can send and receive data in both directions on a given connection at any time.\n\n\n\n\nStream Control Transmission Protocol (SCTP)\n\n\nLike TCP, SCTP provides reliability, sequencing, flow control, and full-duplex data transfer.\n\n\nUnlike TCP, SCTP provides:\n\n\n\n\nAssociation\n instead of \"connection\": An association refers to a communication between two systems, which may involve more than two addresses due to multihoming.\n\n\nMessage-oriented\n: provides sequenced delivery of individual records. Like UDP, the length of a record written by the sender is passed to the receiving application.\n\n\nMultihoming\n: allows a single SCTP endpoint to support multiple IP addresses. This feature can provide increased robustness against network failure.\n\n\n\n\nTCP Connection Establishment and Termination\n\n\nThree-Way Handshake\n\n\n\n\n\n\nServer: \npassive open\n, by calling \nsocket\n, \nbind\n, and \nlisten\n\n\nClient: \nactive open\n, by calling \nconnect\n. The client TCP to send a \"synchronize\" (SYN) segment with no data but it contains client's initial sequence number for the data to be sent on the connection.\n\n\nServer: acknowledges (ACK) client's SYN. The server sends its SYN and the ACK of the client's SYN in a single segment which also contains its own SYN containing the initial sequence number for the data to be sent on the connection.\n\n\nClient: acknowledges the server's SYN.\n\n\n\n\nThe client's initial sequence number as \nJ\n and the server's initial sequence number as \nK\n. The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK. Since a SYN occupies one byte of the sequence number space, the acknowledgment number in the ACK of each SYN is the initial sequence number plus one.\n\n\nTCP Options\n\n\n\n\nMSS option. The TCP sending the SYN announces its \nmaximum segment size\n (the maximum amount of data that it is willing to accept in each TCP segment)on this connection.\n\n\nWindow scale option. [p38]\n\n\nTimestamp option\n\n\n\n\nTCP Connection Termination\n\n\n\n\nIt takes four segments to terminate a connection:\n\n\n\n\nOne end calls \nclose\n first by sending a FIN segment to mean it is finished sending data. This is called \nactive close\n.\n\n\nThe other end that receives the FIN performs the \npassive close\n. The received FIN is acknowledged by TCP (sending an ACK segment). The receipt of the FIN is also passed to the application as an end-of-file.\n\n\nSometime later, the application that received the end-of-file will close its socket. This causes its TCP to send a FIN.\n\n\nThe TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN\n\n\n\n\nA FIN occupies one byte of sequence number space just like a SYN. Therefore, the ACK of each FIN is the sequence number of the FIN plus one.\n\n\nTCP State Transition Diagram\n\n\n\n\nThere are 11 different states defined for a connection and the rules of TCP dictate the transitions from one state to another, based on the current state and the segment received in that state.\n\n\nWatching the Packets\n\n\n\n\nThe client in this example announces an MSS of 536 (\nminimum reassembly buffer size\n) and the server announces an MSS of 1,460 (typical for IPv4 on an Ethernet). It is okay for the MSS to be different in each direction. The acknowledgment of the client's request is sent with the server's reply. This is called \npiggybacking\n and will normally happen when the time it takes the server to process the request and generate the reply is less than around 200 ms. \nWith TCP, there would be eight segments of overhead. If UDP was used, only two packets would be exchanged.\n\n\n\n\nUDP removes all the reliability that TCP provides to the application.\n\n\nUDP avoids the overhead of TCP connection establishment and connection termination.\n\n\n\n\nTIME_WAIT State\n\n\nThe end that performs the active close goes through the TIME_WAIT state. The duration that this endpoint remains in the TIME_WAIT state is twice the \nmaximum segment lifetime\n (MSL), sometimes called 2MSL, which is between 1 and 4 minutes. The MSL is the maximum amount of time that any given IP datagram can live in a network. The IPv4 TTL field  IPv6 hop limit field have a maximum value 255. The assumption is made that a packet with the maximum hop limit of 255 cannot exist in a network for more than MSL seconds. [p43]\n\n\nTCP must handle \nlost duplicates\n (or \nwandering duplicate\n).\n\n\nThere are two reasons for the TIME_WAIT state:\n\n\n\n\nTo implement TCP's full-duplex connection termination reliably. If TCP is performing all the work necessary to terminate both directions of data flow cleanly for a connection (its full-duplex close), then it must correctly handle the loss of any of these four segments.\n\n\nTo allow old duplicate segments to expire in the network. When we successfully establish a TCP connection, all old duplicates from previous \nincarnations\n of the connection have expired in the network.\n\n\n\n\nPort Numbers\n\n\nAll three transport layers (UDP, SCTP and TCP) use 16-bit integer port numbers to differentiate between processes.\n\n\n\n\nThe \nwell-known ports\n: 0 through 1023.\n\n\nThe \nregistered ports\n: 1024 through 49151\n\n\nThe \ndynamic ports\n or \nprivate ports\n, 49152 through 65535. Also called \nephemeral ports\n.\n\n\n\n\nSocket Pair\n\n\n\n\nSocket pair\n: the four-tuple that defines the two endpoints of a TCP connection: the local IP address, local port, foreign IP address, and foreign port. A socket pair uniquely identifies every TCP connection on a network.\n\n\nSocket\n: two values (an IP address and a port number) that identify each endpoint.\n\n\n\n\nTCP Port Numbers and Concurrent Servers\n\n\n[p52-55]\n\n\nBuffer Sizes and Limitations", 
            "title": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP"
        }, 
        {
            "location": "/unp/ch2/#chapter-2-the-transport-layer-tcp-udp-and-sctp", 
            "text": "Introduction  This chapter focuses on the transport layer: TCP, UDP, and Stream Control Transmission Protocol (SCTP). UDP is a simple, unreliable datagram protocol, while TCP is a sophisticated, reliable byte-stream protocol. SCTP is similar to TCP as a reliable transport protocol, but it also provides message boundaries, transport-level support for multihoming, and a way to minimize head-of-line blocking.  The Big Picture  Overview of TCP/IP protocols:     Protocol  Description      IPv4  Internet Protocol version 4. IPv4 uses 32-bit addresses and provides packet delivery service for TCP, UDP, SCTP, ICMP, and IGMP.    IPv6  Internet Protocol version 6. IPv6 uses 128-bit addresses.    TCP  Transmission Control Protocol. TCP is a connection-oriented protocol that provides a reliable, full-duplex byte stream to its users    UDP  User Datagram Protocol. UDP is a connectionless protocol, and UDP sockets are an example of datagram sockets.    SCTP  Stream Control Transmission Protocol. SCTP is a connection-oriented protocol that provides a reliable full-duplex association    ICMP  Internet Control Message Protocol. ICMP handles error and control information between routers and hosts.    IGMP  Internet Group Management Protocol. IGMP is used with multicasting.    ARP  Address Resolution Protocol. ARP maps an IPv4 address into a hardware address (such as an Ethernet address). ARP is normally used on broadcast networks such as Ethernet,  token ring , and  FDDI , and is not needed on point-to-point networks.    RARP  Reverse Address Resolution Protocol. RARP maps a hardware address into an IPv4 address. It is sometimes used when a diskless node is booting.    ICMPv6  Internet Control Message Protocol version 6. ICMPv6 combines the functionality of ICMPv4, IGMP, and ARP.    BPF  BSD packet filter . This interface provides access to the datalink layer. It is normally found on Berkeley-derived kernels.    DLPI  Datalink provider interface .     User Datagram Protocol (UDP)   Lack of reliability  Each UDP datagram has a length  Connectionless  service   Transmission Control Protocol (TCP)   Connection : TCP provides connections between clients and servers. A TCP client establishes a connection with a server, exchanges data across the connection, and then terminates the connection.  Reliability : TCP requires acknowledgment when sending data. If an acknowledgment is not received, TCP automatically retransmits the data and waits a longer amount of time.  Round-trip time  (RTT): TCP estimates RTT between a client and server dynamically so that it knows how long to wait for an acknowledgment.  Sequencing : TCP associates a sequence number with every byte ( segment , unit of data that TCP passes to IP.) it sends. TCP reorders out-of-order segments and discards duplicate segments.  Flow control  Full-duplex : an application can send and receive data in both directions on a given connection at any time.   Stream Control Transmission Protocol (SCTP)  Like TCP, SCTP provides reliability, sequencing, flow control, and full-duplex data transfer.  Unlike TCP, SCTP provides:   Association  instead of \"connection\": An association refers to a communication between two systems, which may involve more than two addresses due to multihoming.  Message-oriented : provides sequenced delivery of individual records. Like UDP, the length of a record written by the sender is passed to the receiving application.  Multihoming : allows a single SCTP endpoint to support multiple IP addresses. This feature can provide increased robustness against network failure.   TCP Connection Establishment and Termination  Three-Way Handshake    Server:  passive open , by calling  socket ,  bind , and  listen  Client:  active open , by calling  connect . The client TCP to send a \"synchronize\" (SYN) segment with no data but it contains client's initial sequence number for the data to be sent on the connection.  Server: acknowledges (ACK) client's SYN. The server sends its SYN and the ACK of the client's SYN in a single segment which also contains its own SYN containing the initial sequence number for the data to be sent on the connection.  Client: acknowledges the server's SYN.   The client's initial sequence number as  J  and the server's initial sequence number as  K . The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK. Since a SYN occupies one byte of the sequence number space, the acknowledgment number in the ACK of each SYN is the initial sequence number plus one.  TCP Options   MSS option. The TCP sending the SYN announces its  maximum segment size  (the maximum amount of data that it is willing to accept in each TCP segment)on this connection.  Window scale option. [p38]  Timestamp option   TCP Connection Termination   It takes four segments to terminate a connection:   One end calls  close  first by sending a FIN segment to mean it is finished sending data. This is called  active close .  The other end that receives the FIN performs the  passive close . The received FIN is acknowledged by TCP (sending an ACK segment). The receipt of the FIN is also passed to the application as an end-of-file.  Sometime later, the application that received the end-of-file will close its socket. This causes its TCP to send a FIN.  The TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN   A FIN occupies one byte of sequence number space just like a SYN. Therefore, the ACK of each FIN is the sequence number of the FIN plus one.  TCP State Transition Diagram   There are 11 different states defined for a connection and the rules of TCP dictate the transitions from one state to another, based on the current state and the segment received in that state.  Watching the Packets   The client in this example announces an MSS of 536 ( minimum reassembly buffer size ) and the server announces an MSS of 1,460 (typical for IPv4 on an Ethernet). It is okay for the MSS to be different in each direction. The acknowledgment of the client's request is sent with the server's reply. This is called  piggybacking  and will normally happen when the time it takes the server to process the request and generate the reply is less than around 200 ms. \nWith TCP, there would be eight segments of overhead. If UDP was used, only two packets would be exchanged.   UDP removes all the reliability that TCP provides to the application.  UDP avoids the overhead of TCP connection establishment and connection termination.   TIME_WAIT State  The end that performs the active close goes through the TIME_WAIT state. The duration that this endpoint remains in the TIME_WAIT state is twice the  maximum segment lifetime  (MSL), sometimes called 2MSL, which is between 1 and 4 minutes. The MSL is the maximum amount of time that any given IP datagram can live in a network. The IPv4 TTL field  IPv6 hop limit field have a maximum value 255. The assumption is made that a packet with the maximum hop limit of 255 cannot exist in a network for more than MSL seconds. [p43]  TCP must handle  lost duplicates  (or  wandering duplicate ).  There are two reasons for the TIME_WAIT state:   To implement TCP's full-duplex connection termination reliably. If TCP is performing all the work necessary to terminate both directions of data flow cleanly for a connection (its full-duplex close), then it must correctly handle the loss of any of these four segments.  To allow old duplicate segments to expire in the network. When we successfully establish a TCP connection, all old duplicates from previous  incarnations  of the connection have expired in the network.   Port Numbers  All three transport layers (UDP, SCTP and TCP) use 16-bit integer port numbers to differentiate between processes.   The  well-known ports : 0 through 1023.  The  registered ports : 1024 through 49151  The  dynamic ports  or  private ports , 49152 through 65535. Also called  ephemeral ports .   Socket Pair   Socket pair : the four-tuple that defines the two endpoints of a TCP connection: the local IP address, local port, foreign IP address, and foreign port. A socket pair uniquely identifies every TCP connection on a network.  Socket : two values (an IP address and a port number) that identify each endpoint.   TCP Port Numbers and Concurrent Servers  [p52-55]  Buffer Sizes and Limitations", 
            "title": "Chapter 2. The Transport Layer: TCP, UDP, and SCTP"
        }, 
        {
            "location": "/icnd1/part1/", 
            "text": "Part I: Networking Fundamentals\n\n\nChapter 1. Introduction to Computer Networking\n\n\nChapter 2. The TCP/IP and OSI Networking Models\n\n\nTCP/IP Networking Model\n\n\nA \nnetworking model\n (\nnetworking architecture\n or \nnetworking blueprint\n), refers to a comprehensive set of documents that define everything that should happen for a computer network to work.\n\n\nThe TCP/IP model both defines and references a large collection of protocols that allow computers to communicate. TCP/IP uses documents called \nRequests for Comments\n (RFC).\n\n\nData Encapsulation Terminology\n\n\n\n\n\n\nCreate and encapsulate the application data with any required application layer headers.\n\n\nEncapsulate the data supplied by the application layer inside a transport layer header. \n\n\nEncapsulate the data supplied by the transport layer inside an Internet layer (IP) header.\n\n\nEncapsulate the data supplied by the Internet layer inside a data link layer header and trailer. This is the only layer that uses both a \nheader\n and a \ntrailer\n.\n\n\nTransmit the bits.\n\n\n\n\nOSI Networking Model\n\n\n\n\nDescribing Protocols by Referencing the OSI Layers\n\n\nNetworking documents often describe TCP/IP protocols and standards by referencing OSI layers, both by layer number and layer name. For instance, a common description of a LAN switch is \u201clayer 2 switch,\u201d with \u201clayer 2\u201d referring to OSI layer 2.\n\n\n\n\n\n\n\n\nLayer Name\n\n\nProtocols and Specifications\n\n\nDevices\n\n\n\n\n\n\n\n\n\n\nApplication, presentation, session (Layers 5\u20137)\n\n\nTelnet, HTTP, FTP, SMTP, POP3, VoIP, SNMP\n\n\nFirewall, intrusion detection systems, hosts\n\n\n\n\n\n\nTransport (Layer 4)\n\n\nTCP, UDP\n\n\nHosts, firewalls\n\n\n\n\n\n\nNetwork (Layer 3)\n\n\nIP\n\n\nRouter\n\n\n\n\n\n\nData link (Layer 2)\n\n\nEthernet (IEEE 802.3), HDLC, Frame Relay, PPP\n\n\nLAN switch, wireless access point, cable modem, DSL modem\n\n\n\n\n\n\nPhysical (Layer 1)\n\n\nRJ-45, EIA/TIA-232, V.35, Ethernet (IEEE 802.3)\n\n\nLAN hub, LAN repeater, cables\n\n\n\n\n\n\n\n\nOSI Layering Concepts and Benefits\n\n\n[p41]\n\n\n\n\nLess complex\n\n\nStandard interfaces\n\n\nEasier to learn\n\n\nEasier to develop\n\n\nMultivendor interoperability\n\n\nModular engineering\n\n\n\n\nOSI Encapsulation Terminology\n\n\n\n\nThe TCP/IP model uses terms such as \nsegment\n, \npacket\n, and \nframe\n to refer to various layers and their respective encapsulated data. OSI uses a more generic term: \nprotocol data unit\n (PDU).\n\n\nChapter 3. Fundamentals of LANs\n\n\nAn Overview of Modern Ethernet LANs\n\n\nTypes of cabling:\n\n\n\n\nUnshielded Twisted-Pair\n (UTP)\n\n\nFiber-optic\n\n\n\n\nMost IEEE standards define a different variation of Ethernet at the physical layer. \nFor the data link layer:\n\n\n\n\n802.3 Media Access Control (MAC) sublayer\n\n\n802.2 Logical Link Control (LLC) sublayer\n\n\n\n\n[p52]\n\n\n\n\n\n\n\n\nCommon Name\n\n\nSpeed\n\n\nAlternative Name\n\n\nName of IEEE Standard\n\n\nCable Type, Maximum Length\n\n\n\n\n\n\n\n\n\n\nEthernet\n\n\n10 Mbps\n\n\n10BASE-T\n\n\nIEEE 802.3\n\n\nCopper, 100 m\n\n\n\n\n\n\nFast Ethernet\n\n\n100 Mbps\n\n\n100BASE-TX\n\n\nIEEE 802.3u\n\n\nCopper, 100 m\n\n\n\n\n\n\nGigabit Ethernet\n\n\n1000 Mbps\n\n\n1000BASE-LX, 1000BASE-SX\n\n\nIEEE 802.3z\n\n\nFiber, 550 m (SX) 5 km (LX)\n\n\n\n\n\n\nGigabit Ethernet\n\n\n1000 Mbps\n\n\n1000BASE-T\n\n\nIEEE 802.3ab\n\n\n100 m\n\n\n\n\n\n\n\n\nThe term Ethernet is often used to mean \"all types of Ethernet\", but in some cases it is used to mean \"10BASE-T Ethernet\"\n\n\nA Brief History of Ethernet\n\n\n\n\nCarrier sense multiple access with collision detection (CSMA/CD) algorithm\n\n\n\n\nRepeaters\n\n\nRepeaters\n extended the length of LANs by cleaning up the electrical signal and repeating it (a Layer 1 function) but without interpreting the meaning of the electrical signal. [p56]\n\n\nBuilding 10BASE-T Networks with Hubs\n\n\nHubs\n are essentially repeaters with multiple physical ports. It simply regenerates the electrical signal that comes in one port and sends the same signal out every other port.\n\n\nEthernet UTP Cabling\n\n\nTransmitting Data Using Twisted Pairs\n\n\nUTP cabling consists of matched pairs of wires that are indeed twisted together, with current on the two wires in opposite directions.\n\n\nUTP Cabling Pinouts for \n10BASE-T and 100BASE-TX\n\n\n10BASE-T and 100BASE-TX Ethernet define that one pair should be used to send data in one direction, with the other pair used to send data in the other direction.\n\n\nThe wires in the UTP cable must be connected to the correct \npin positions\n in the RJ-45 connectors in order for communication to work correctly. \n\n\n[p62-64]\n\n\nThe following applies to 10BASE-T and 100BASE-TX only:\n\n\n\n\nEthernet \nstraight-through cable\n: both ends of the cable use the same EIA/TIA pinout standard on each end of the cable. A straight-through cable is used when the devices on the ends of the cable use opposite pins when they transmit data.\n\n\nEthernet \ncrossover cable\n:  two devices both use the same pins to transmit and the pinouts of the cable are set up to swap the wire pair\n\n\n\n\n\n\n\n\n\n\nDevices That Transmit on 1,2 and Receive on 3,6\n\n\nDevices That Transmit on 3,6 and Receive on 1,2\n\n\n\n\n\n\n\n\n\n\nPC NICs\n\n\nHubs\n\n\n\n\n\n\nRouters\n\n\nSwitches\n\n\n\n\n\n\nWireless Access Point (Ethernet interface)\n\n\n\u2014\n\n\n\n\n\n\nNetworked printers (printers that connect directly to the LAN)\n\n\n\u2014\n\n\n\n\n\n\n\n\n1000BASE-T Cabling\n\n\n1000BASE-T differs from 10BASE-T and 100BASE-TX as far as the cabling and pinouts:\n\n\n\n\nReequires four wire pairs\n\n\nTransmits and receives on each of the four wire pairs simultaneously\n\n\nHas no concept of straight-through and crossover cables\n\n\n\n\nImproving Performance by Using Switches Instead of Hubs\n\n\nCSMA/CD logic helps prevent collisions and also defines how to act when a collision does occur:\n\n\n\n\nA device with a frame to send listens until the Ethernet is not busy.\n\n\nWhen the Ethernet is not busy, the sender(s) begin(s) sending the frame.\n\n\nThe sender(s) listen(s) to make sure that no collision occurred.\n\n\nIf a collision occurs, the devices that had been sending a frame each send a jamming signal to ensure that all stations recognize the collision.\n\n\nAfter the jamming is complete, each sender randomizes a timer and waits that long before trying to resend the collided frame. When each random timer expires, the process starts over with Step 1.\n\n\n\n\nIncreasing Available Bandwidth Using Switches\n\n\nThe term \ncollision domain\n defines the set of devices whose frames could collide. For example, all devices connected to the hub are in the same collision domain. To avoid collisions, and to recover when they occur, devices in the same collision domain use CSMA/CD.\n\n\nSwitches\n significantly reduce, or even eliminate, the number of collisions on a LAN:\n\n\n\n\nSwitches interpret the bits in the received frame so that they can typically send the frame out the one required port, rather than all other ports\n\n\nIf a switch needs to forward multiple frames out the same port, the switch buffers the frames in memory, sending one at a time, thereby avoiding collisions\n\n\n\n\nThe switch\u2019s logic requires that the switch look at the Ethernet header, which is considered a Layer 2 feature. As a result, switches are considered to operate as a Layer 2 device, whereas hubs are Layer 1 devices.\n\n\nBuffering (temporarily holds the frame in memory) also helps prevent collisions.\n\n\nSwitch features provide significant performance improvements:\n\n\n\n\nIf only one device is cabled to each port of a switch, no collisions can occur.\n\n\nDevices connected to one switch port do not share their bandwidth with devices connected to another switch port. Each has its own separate bandwidth, meaning that a switch with 100-Mbps ports has 100 Mbps of bandwidth \nper port\n.\n\n\n\n\nShared Ethernet vs. Switched Ethernet\n\n\n\n\nShared Ethernet\n: bandwidth is shared among the devices on the LAN because they must take turns using the LAN because of the CSMA/CD algorithm. A hub with 24 100-Mbps Ethernet devices connected to it allows for a theoretical maximum of 100 Mbps of bandwidth\n\n\nSwitched Ethernet\n: bandwidth does not have to be shared, allowing for far greater performance. A switch with 24 100-Mbps Ethernet devices connected to it supports 100 Mbps for each port, or 2400 Mbps (2.4 Gbps) theoretical maximum bandwidth.\n\n\n\n\nDoubling Performance by Using Full-Duplex Ethernet\n\n\nIn an Ethernet network using hubs, CSMA/CD imposes \nhalf-duplex\n logic on each device, meaning that only one device can send at a time. LAN switches with only one device cabled to each port of the switch allow the use of \nfull-duplex\n operation; Ethernet card can send and receive concurrently.\n\n\nEthernet Data-Link Protocols\n\n\nEthernet Addressing\n\n\n\n\n\n\n\n\nLAN Addressing Term or Feature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMAC\n\n\nMedia Access Control. 802.3 (Ethernet) defines the MAC sublayer of IEEE Ethernet.\n\n\n\n\n\n\nEthernet address, NIC address, LAN address\n\n\nOther names often used instead of MAC address. These terms describe the 6-byte address of the LAN interface card.\n\n\n\n\n\n\nBurned-in address\n\n\nThe 6-byte address assigned by the vendor making the card.\n\n\n\n\n\n\nUnicast address\n\n\nA term for a MAC that represents a single LAN interface.\n\n\n\n\n\n\nBroadcast address\n\n\nAn address that means \u201call devices that reside on this LAN right now.\u201d (FFFF.FFFF.FFFF)\n\n\n\n\n\n\nMulticast address\n\n\nOn Ethernet, a multicast address implies some subset of all devices currently on the Ethernet LAN. (0100.5exx.xxxx, any value can be used in the last half)\n\n\n\n\n\n\n\n\nEthernet Framing\n\n\nFraming\n defines the meaning of the bits transmitted and received over a network.\n\n\n\n\n\n\nData\n field holds Layer 3 packets (L3 PDU)\n\n\nMaximum transmission unit\n (MTU) defines the maximum Layer 3 packet that can be sent over a medium. 1500 bytes is the largest IP MTU allowed over an Ethernet.\n\n\n\n\nIdentifying the Data Inside an Ethernet Frame\n\n\nType/Length\n filed:\n\n\n\n\nLength\n field: with a value less than hex 0600 (decimal 1536); another field is needed to identify the type of L3 PDU inside the frame.\n\n\nType\n field: value of hexadecimal 0800 (decimal 2048) implies an IP packet\n\n\n\n\nError Detection\n\n\nErrors (bit changes) occur due to electrical interference. Trailer containing a \nFrame Check Sequence\n (FCS) field used for error detection.\n\n\nChapter 4. Fundamentals of WANs\n\n\nThe WAN topics in this chapter describe mainly how enterprise networks use WANs to connect remote sites.\n\n\nOSI Layer 1 for Point-to-Point WANs\n\n\n\n\nLeased line\n or \nleased circuit\n: WAN cable, line or point-to-point connection that is paid for use\n\n\nTelephone company (telco), or public telephone and telegraph (PTT)\n\n\nService provider\n: a company that provides any form of WAN connectivity, including Internet services.\n\n\n\n\nRouters provide the capability to connect many different types of OSI Layer 1 and Layer 2 technologies. A router is connected to each end of a WAN connection.\n\n\n\n\n\n\nCentral Office (CO): a building where the telco locates the devices used to create its own network\n\n\nChannel service unit/data service (\nCSU/DSU\n)\n\n\ndemarc\n (\ndemarcation point\n): he point at which the telco\u2019s responsibility is on one side and the customer\u2019s responsibility is on the other\n\n\nCustomer premises equipment\n (CPE): devices that are at the customer site\n\n\n\n\nWAN Cabling Standards\n\n\n[p84]\n\n\nClock Rates, Synchronization, DCE, and DTE\n\n\n[p86]\n\n\n\n\nSynchronization: various devices need to synchronize their clocks so that they run at exactly the same speed to make a link work\n\n\nData communications equipment (DCE): device that provides clocking, typically the CSU/DSU\n\n\nData terminal equipment (DTE): device receiving clocking, typically the router\n\n\n\n\nLink Speeds\n\n\n\n\n\n\n\n\nName(s) of Line\n\n\nBit Rate\n\n\n\n\n\n\n\n\n\n\nDS0\n\n\n64 kbps\n\n\n\n\n\n\nDS1 (T1)\n\n\n1.544 Mbps (24 DS0s, plus 8 kbps overhead)\n\n\n\n\n\n\nDS3 (T3)\n\n\n44.736 Mbps (28 DS1s, plus management overhead)\n\n\n\n\n\n\nE1\n\n\n2.048 Mbps (32 DS0s)\n\n\n\n\n\n\nE3\n\n\n34.368 Mbps (16 E1s, plus management overhead)\n\n\n\n\n\n\nJ1 (Y1)\n\n\n2.048 Mbps (32 DS0s; Japanese standard)\n\n\n\n\n\n\n\n\nOSI Layer 2 for Point-to-Point WANs\n\n\nHDLC\n\n\n\n\nHigh-Level Data Link Control\n (HDLC) defines framing to:\n\n\n\n\nDelivers data across the link \n\n\nCheck for errors\n\n\nIdentify the packet type\n\n\n\n\nPoint-to-Point Protocol\n\n\nPoint-to-Point Protocol (PPP) behaves much like HDLC. The framing looks identical to the Cisco proprietary HDLC framing. PPP has become the most popular and feature-rich of WAN data link layer protocols. [p91]\n\n\nPoint-to-Point WAN Summary\n\n\nWAN Terminology [p91-92]\n\n\n\n\nSynchronous: The imposition of time ordering on a bit stream\n\n\nClock source: The device to which the other devices on the link adjust their speed when using synchronous links\n\n\nCSU/DSU: Used on digital links as an interface to the telephone company in the United States. Routers typically use a short cable from a serial interface to a CSU/DSU, which is attached to the line from the telco\n\n\nTelco\n\n\nFour-wire circuit: A line from the telco with four wires, composed of two twisted-pair wires. Each pair is used to send in one direction, so a four-wire circuit allows full-duplex communication.\n\n\nT1\n\n\nE1\n\n\n\n\nAll the following terms may be used to refer to a point-to-point leased line:\n\n\n\n\nleased line\n\n\nleased circuit\n\n\nlink\n\n\nserial link\n\n\nserial line\n\n\npoint-to-point link\n\n\ncircuit\n\n\n\n\nFrame Relay and Packet-Switching Services\n\n\nPacket-switching service\n: a company can connect a large number of routers using a single serial link from each router into the packet-switching service. Once connected, each router can send packets to all the other routers\u2014much like all the devices connected to an Ethernet hub or switch can send data directly to each other.\n\n\nTwo types of packet-switching service are very popular today:\n\n\n\n\nFrame Relay: much more common\n\n\nAsynchronous Transfer Mode (ATM)\n\n\n\n\nChapter 5. Fundamentals of IPv4 Addressing and Routing\n\n\n\n\nRouting: the process of forwarding packets (Layer 3 PDUs).\n\n\nLogical addressing: enables the routing process to identify a packet\u2019s source and destination.\n\n\nRouting protocol: aids routers by dynamically learning about the groups of addresses in the network, which in turn allows the routing (forwarding) process to work well.\n\n\nOther utilities: The network layer also relies on other utilities: Domain Name System (DNS), Dynamic Host Configuration Protocol (DHCP), Address Resolution Protocol (ARP), and ping.\n\n\n\n\nPath selection\n sometimes is used to mean:\n\n\n\n\nRouting protocol\n\n\nRouting (forwarding) of packets\n\n\n\n\nOverview of Network Layer Functions\n\n\nToday, the only Layer 3 protocol that is used widely is the TCP/IP network layer protocol, specifically, IP.  IP does not require any overhead agreements or messages before sending a packet, making IP a connectionless protocol, with no error recovery.\n\n\nRouting (Forwarding)\n\n\nRouting focuses on the end-to-end logic of forwarding data.\n\n\nThe routing table for any particular network layer protocol contains a list of network layer address groupings. Instead of a single entry in the routing table per individual destination network layer address, there is one routing table entry per group.\n\n\nNetwork Layer Interaction with the Data Link Layer\n\n\nThe routing process forwards the packet, and only the packet, end-to-end through the network, discarding data-link headers and trailers along the way.\n\n\nRouters build new data-link headers and trailers and because the new headers contain data-link addresses, the PCs and routers must decide what data-link addresses to use. The Address Resolution Protocol (ARP) is used to dynamically learn the data-link address of an IP host connected to a LAN.\n\n\nRouting as covered so far has two main concepts:\n\n\n\n\nThe process of routing forwards Layer 3 packets, also called Layer 3 protocol data units (L3 PDU), based on the destination Layer 3 address in the packet.\n\n\nThe routing process uses the data link layer to encapsulate the Layer 3 packets into Layer 2 frames for transmission across each successive data link.", 
            "title": "ICND1 Part I: Networking Fundamentals"
        }, 
        {
            "location": "/icnd1/part1/#chapter-1-introduction-to-computer-networking", 
            "text": "", 
            "title": "Chapter 1. Introduction to Computer Networking"
        }, 
        {
            "location": "/icnd1/part1/#chapter-2-the-tcpip-and-osi-networking-models", 
            "text": "TCP/IP Networking Model  A  networking model  ( networking architecture  or  networking blueprint ), refers to a comprehensive set of documents that define everything that should happen for a computer network to work.  The TCP/IP model both defines and references a large collection of protocols that allow computers to communicate. TCP/IP uses documents called  Requests for Comments  (RFC).  Data Encapsulation Terminology    Create and encapsulate the application data with any required application layer headers.  Encapsulate the data supplied by the application layer inside a transport layer header.   Encapsulate the data supplied by the transport layer inside an Internet layer (IP) header.  Encapsulate the data supplied by the Internet layer inside a data link layer header and trailer. This is the only layer that uses both a  header  and a  trailer .  Transmit the bits.   OSI Networking Model   Describing Protocols by Referencing the OSI Layers  Networking documents often describe TCP/IP protocols and standards by referencing OSI layers, both by layer number and layer name. For instance, a common description of a LAN switch is \u201clayer 2 switch,\u201d with \u201clayer 2\u201d referring to OSI layer 2.     Layer Name  Protocols and Specifications  Devices      Application, presentation, session (Layers 5\u20137)  Telnet, HTTP, FTP, SMTP, POP3, VoIP, SNMP  Firewall, intrusion detection systems, hosts    Transport (Layer 4)  TCP, UDP  Hosts, firewalls    Network (Layer 3)  IP  Router    Data link (Layer 2)  Ethernet (IEEE 802.3), HDLC, Frame Relay, PPP  LAN switch, wireless access point, cable modem, DSL modem    Physical (Layer 1)  RJ-45, EIA/TIA-232, V.35, Ethernet (IEEE 802.3)  LAN hub, LAN repeater, cables     OSI Layering Concepts and Benefits  [p41]   Less complex  Standard interfaces  Easier to learn  Easier to develop  Multivendor interoperability  Modular engineering   OSI Encapsulation Terminology   The TCP/IP model uses terms such as  segment ,  packet , and  frame  to refer to various layers and their respective encapsulated data. OSI uses a more generic term:  protocol data unit  (PDU).", 
            "title": "Chapter 2. The TCP/IP and OSI Networking Models"
        }, 
        {
            "location": "/icnd1/part1/#chapter-3-fundamentals-of-lans", 
            "text": "An Overview of Modern Ethernet LANs  Types of cabling:   Unshielded Twisted-Pair  (UTP)  Fiber-optic   Most IEEE standards define a different variation of Ethernet at the physical layer. \nFor the data link layer:   802.3 Media Access Control (MAC) sublayer  802.2 Logical Link Control (LLC) sublayer   [p52]     Common Name  Speed  Alternative Name  Name of IEEE Standard  Cable Type, Maximum Length      Ethernet  10 Mbps  10BASE-T  IEEE 802.3  Copper, 100 m    Fast Ethernet  100 Mbps  100BASE-TX  IEEE 802.3u  Copper, 100 m    Gigabit Ethernet  1000 Mbps  1000BASE-LX, 1000BASE-SX  IEEE 802.3z  Fiber, 550 m (SX) 5 km (LX)    Gigabit Ethernet  1000 Mbps  1000BASE-T  IEEE 802.3ab  100 m     The term Ethernet is often used to mean \"all types of Ethernet\", but in some cases it is used to mean \"10BASE-T Ethernet\"  A Brief History of Ethernet   Carrier sense multiple access with collision detection (CSMA/CD) algorithm   Repeaters  Repeaters  extended the length of LANs by cleaning up the electrical signal and repeating it (a Layer 1 function) but without interpreting the meaning of the electrical signal. [p56]  Building 10BASE-T Networks with Hubs  Hubs  are essentially repeaters with multiple physical ports. It simply regenerates the electrical signal that comes in one port and sends the same signal out every other port.  Ethernet UTP Cabling  Transmitting Data Using Twisted Pairs  UTP cabling consists of matched pairs of wires that are indeed twisted together, with current on the two wires in opposite directions.  UTP Cabling Pinouts for  10BASE-T and 100BASE-TX  10BASE-T and 100BASE-TX Ethernet define that one pair should be used to send data in one direction, with the other pair used to send data in the other direction.  The wires in the UTP cable must be connected to the correct  pin positions  in the RJ-45 connectors in order for communication to work correctly.   [p62-64]  The following applies to 10BASE-T and 100BASE-TX only:   Ethernet  straight-through cable : both ends of the cable use the same EIA/TIA pinout standard on each end of the cable. A straight-through cable is used when the devices on the ends of the cable use opposite pins when they transmit data.  Ethernet  crossover cable :  two devices both use the same pins to transmit and the pinouts of the cable are set up to swap the wire pair      Devices That Transmit on 1,2 and Receive on 3,6  Devices That Transmit on 3,6 and Receive on 1,2      PC NICs  Hubs    Routers  Switches    Wireless Access Point (Ethernet interface)  \u2014    Networked printers (printers that connect directly to the LAN)  \u2014     1000BASE-T Cabling  1000BASE-T differs from 10BASE-T and 100BASE-TX as far as the cabling and pinouts:   Reequires four wire pairs  Transmits and receives on each of the four wire pairs simultaneously  Has no concept of straight-through and crossover cables   Improving Performance by Using Switches Instead of Hubs  CSMA/CD logic helps prevent collisions and also defines how to act when a collision does occur:   A device with a frame to send listens until the Ethernet is not busy.  When the Ethernet is not busy, the sender(s) begin(s) sending the frame.  The sender(s) listen(s) to make sure that no collision occurred.  If a collision occurs, the devices that had been sending a frame each send a jamming signal to ensure that all stations recognize the collision.  After the jamming is complete, each sender randomizes a timer and waits that long before trying to resend the collided frame. When each random timer expires, the process starts over with Step 1.   Increasing Available Bandwidth Using Switches  The term  collision domain  defines the set of devices whose frames could collide. For example, all devices connected to the hub are in the same collision domain. To avoid collisions, and to recover when they occur, devices in the same collision domain use CSMA/CD.  Switches  significantly reduce, or even eliminate, the number of collisions on a LAN:   Switches interpret the bits in the received frame so that they can typically send the frame out the one required port, rather than all other ports  If a switch needs to forward multiple frames out the same port, the switch buffers the frames in memory, sending one at a time, thereby avoiding collisions   The switch\u2019s logic requires that the switch look at the Ethernet header, which is considered a Layer 2 feature. As a result, switches are considered to operate as a Layer 2 device, whereas hubs are Layer 1 devices.  Buffering (temporarily holds the frame in memory) also helps prevent collisions.  Switch features provide significant performance improvements:   If only one device is cabled to each port of a switch, no collisions can occur.  Devices connected to one switch port do not share their bandwidth with devices connected to another switch port. Each has its own separate bandwidth, meaning that a switch with 100-Mbps ports has 100 Mbps of bandwidth  per port .   Shared Ethernet vs. Switched Ethernet   Shared Ethernet : bandwidth is shared among the devices on the LAN because they must take turns using the LAN because of the CSMA/CD algorithm. A hub with 24 100-Mbps Ethernet devices connected to it allows for a theoretical maximum of 100 Mbps of bandwidth  Switched Ethernet : bandwidth does not have to be shared, allowing for far greater performance. A switch with 24 100-Mbps Ethernet devices connected to it supports 100 Mbps for each port, or 2400 Mbps (2.4 Gbps) theoretical maximum bandwidth.   Doubling Performance by Using Full-Duplex Ethernet  In an Ethernet network using hubs, CSMA/CD imposes  half-duplex  logic on each device, meaning that only one device can send at a time. LAN switches with only one device cabled to each port of the switch allow the use of  full-duplex  operation; Ethernet card can send and receive concurrently.  Ethernet Data-Link Protocols  Ethernet Addressing     LAN Addressing Term or Feature  Description      MAC  Media Access Control. 802.3 (Ethernet) defines the MAC sublayer of IEEE Ethernet.    Ethernet address, NIC address, LAN address  Other names often used instead of MAC address. These terms describe the 6-byte address of the LAN interface card.    Burned-in address  The 6-byte address assigned by the vendor making the card.    Unicast address  A term for a MAC that represents a single LAN interface.    Broadcast address  An address that means \u201call devices that reside on this LAN right now.\u201d (FFFF.FFFF.FFFF)    Multicast address  On Ethernet, a multicast address implies some subset of all devices currently on the Ethernet LAN. (0100.5exx.xxxx, any value can be used in the last half)     Ethernet Framing  Framing  defines the meaning of the bits transmitted and received over a network.    Data  field holds Layer 3 packets (L3 PDU)  Maximum transmission unit  (MTU) defines the maximum Layer 3 packet that can be sent over a medium. 1500 bytes is the largest IP MTU allowed over an Ethernet.   Identifying the Data Inside an Ethernet Frame  Type/Length  filed:   Length  field: with a value less than hex 0600 (decimal 1536); another field is needed to identify the type of L3 PDU inside the frame.  Type  field: value of hexadecimal 0800 (decimal 2048) implies an IP packet   Error Detection  Errors (bit changes) occur due to electrical interference. Trailer containing a  Frame Check Sequence  (FCS) field used for error detection.", 
            "title": "Chapter 3. Fundamentals of LANs"
        }, 
        {
            "location": "/icnd1/part1/#chapter-4-fundamentals-of-wans", 
            "text": "The WAN topics in this chapter describe mainly how enterprise networks use WANs to connect remote sites.  OSI Layer 1 for Point-to-Point WANs   Leased line  or  leased circuit : WAN cable, line or point-to-point connection that is paid for use  Telephone company (telco), or public telephone and telegraph (PTT)  Service provider : a company that provides any form of WAN connectivity, including Internet services.   Routers provide the capability to connect many different types of OSI Layer 1 and Layer 2 technologies. A router is connected to each end of a WAN connection.    Central Office (CO): a building where the telco locates the devices used to create its own network  Channel service unit/data service ( CSU/DSU )  demarc  ( demarcation point ): he point at which the telco\u2019s responsibility is on one side and the customer\u2019s responsibility is on the other  Customer premises equipment  (CPE): devices that are at the customer site   WAN Cabling Standards  [p84]  Clock Rates, Synchronization, DCE, and DTE  [p86]   Synchronization: various devices need to synchronize their clocks so that they run at exactly the same speed to make a link work  Data communications equipment (DCE): device that provides clocking, typically the CSU/DSU  Data terminal equipment (DTE): device receiving clocking, typically the router   Link Speeds     Name(s) of Line  Bit Rate      DS0  64 kbps    DS1 (T1)  1.544 Mbps (24 DS0s, plus 8 kbps overhead)    DS3 (T3)  44.736 Mbps (28 DS1s, plus management overhead)    E1  2.048 Mbps (32 DS0s)    E3  34.368 Mbps (16 E1s, plus management overhead)    J1 (Y1)  2.048 Mbps (32 DS0s; Japanese standard)     OSI Layer 2 for Point-to-Point WANs  HDLC   High-Level Data Link Control  (HDLC) defines framing to:   Delivers data across the link   Check for errors  Identify the packet type   Point-to-Point Protocol  Point-to-Point Protocol (PPP) behaves much like HDLC. The framing looks identical to the Cisco proprietary HDLC framing. PPP has become the most popular and feature-rich of WAN data link layer protocols. [p91]  Point-to-Point WAN Summary  WAN Terminology [p91-92]   Synchronous: The imposition of time ordering on a bit stream  Clock source: The device to which the other devices on the link adjust their speed when using synchronous links  CSU/DSU: Used on digital links as an interface to the telephone company in the United States. Routers typically use a short cable from a serial interface to a CSU/DSU, which is attached to the line from the telco  Telco  Four-wire circuit: A line from the telco with four wires, composed of two twisted-pair wires. Each pair is used to send in one direction, so a four-wire circuit allows full-duplex communication.  T1  E1   All the following terms may be used to refer to a point-to-point leased line:   leased line  leased circuit  link  serial link  serial line  point-to-point link  circuit   Frame Relay and Packet-Switching Services  Packet-switching service : a company can connect a large number of routers using a single serial link from each router into the packet-switching service. Once connected, each router can send packets to all the other routers\u2014much like all the devices connected to an Ethernet hub or switch can send data directly to each other.  Two types of packet-switching service are very popular today:   Frame Relay: much more common  Asynchronous Transfer Mode (ATM)", 
            "title": "Chapter 4. Fundamentals of WANs"
        }, 
        {
            "location": "/icnd1/part1/#chapter-5-fundamentals-of-ipv4-addressing-and-routing", 
            "text": "Routing: the process of forwarding packets (Layer 3 PDUs).  Logical addressing: enables the routing process to identify a packet\u2019s source and destination.  Routing protocol: aids routers by dynamically learning about the groups of addresses in the network, which in turn allows the routing (forwarding) process to work well.  Other utilities: The network layer also relies on other utilities: Domain Name System (DNS), Dynamic Host Configuration Protocol (DHCP), Address Resolution Protocol (ARP), and ping.   Path selection  sometimes is used to mean:   Routing protocol  Routing (forwarding) of packets   Overview of Network Layer Functions  Today, the only Layer 3 protocol that is used widely is the TCP/IP network layer protocol, specifically, IP.  IP does not require any overhead agreements or messages before sending a packet, making IP a connectionless protocol, with no error recovery.  Routing (Forwarding)  Routing focuses on the end-to-end logic of forwarding data.  The routing table for any particular network layer protocol contains a list of network layer address groupings. Instead of a single entry in the routing table per individual destination network layer address, there is one routing table entry per group.  Network Layer Interaction with the Data Link Layer  The routing process forwards the packet, and only the packet, end-to-end through the network, discarding data-link headers and trailers along the way.  Routers build new data-link headers and trailers and because the new headers contain data-link addresses, the PCs and routers must decide what data-link addresses to use. The Address Resolution Protocol (ARP) is used to dynamically learn the data-link address of an IP host connected to a LAN.  Routing as covered so far has two main concepts:   The process of routing forwards Layer 3 packets, also called Layer 3 protocol data units (L3 PDU), based on the destination Layer 3 address in the packet.  The routing process uses the data link layer to encapsulate the Layer 3 packets into Layer 2 frames for transmission across each successive data link.", 
            "title": "Chapter 5. Fundamentals of IPv4 Addressing and Routing"
        }, 
        {
            "location": "/icnd2/part1/", 
            "text": "Part I: LAN Switching\n\n\nChapter 1. Virtual LANs", 
            "title": "ICND2 Part I: LAN Switching"
        }, 
        {
            "location": "/icnd2/part1/#chapter-1-virtual-lans", 
            "text": "", 
            "title": "Chapter 1. Virtual LANs"
        }, 
        {
            "location": "/tcpv1/ch1/", 
            "text": "Chapter 1. Introduction\n\n\nSome terms [p1]:\n\n\n\n\nGateways\n: later called routers\n\n\nCatenet\n (\"concatenated\" network): obsolete term, later called internetwork\n\n\n\n\nThis chapter provides an overview of the Internet architecture and TCP/IP protocol suite.\n\n\nArchitectural Principles\n\n\nDesign and Implementation\n\n\nThe Architecture and Protocols of the TCP/IP Suite\n\n\nInternets, Intranets, and Extranets", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/tcpv1/ch1/#chapter-1-introduction", 
            "text": "Some terms [p1]:   Gateways : later called routers  Catenet  (\"concatenated\" network): obsolete term, later called internetwork   This chapter provides an overview of the Internet architecture and TCP/IP protocol suite.  Architectural Principles  Design and Implementation  The Architecture and Protocols of the TCP/IP Suite  Internets, Intranets, and Extranets", 
            "title": "Chapter 1. Introduction"
        }, 
        {
            "location": "/tcpv1/ch2/", 
            "text": "Chapter 2. The Internet Address Architecture", 
            "title": "Chapter 2. The Internet Address Architecture"
        }, 
        {
            "location": "/tcpv1/ch2/#chapter-2-the-internet-address-architecture", 
            "text": "", 
            "title": "Chapter 2. The Internet Address Architecture"
        }, 
        {
            "location": "/tcpv1/headers/", 
            "text": "Headers\n\n\nIPv4 Header\n\n\n\n\nIPv6 Header\n\n\n\n\nUDP Header\n\n\n\n\nTCP Header", 
            "title": "Headers"
        }, 
        {
            "location": "/tcpv1/headers/#headers", 
            "text": "IPv4 Header   IPv6 Header   UDP Header   TCP Header", 
            "title": "Headers"
        }, 
        {
            "location": "/htae/", 
            "text": "Hacking: The Art of Exploitation, 2nd Edition\n\n\n0x200 Programming", 
            "title": "HTAE"
        }, 
        {
            "location": "/htae/#0x200-programming", 
            "text": "", 
            "title": "0x200 Programming"
        }, 
        {
            "location": "/golang/", 
            "text": "Golang\n\n\nStructs\n\n\nVisibility\n\n\nThe naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.\n\n\nFactory methods\n\n\nForce using factory methods on a private type [TWTG p233]:\n\n\nwrong := new(matrix.matrix)    // will NOT compile (matrix is private)\nright := matrix.NewMatrix(...)   // the ONLY way to instantiate a matrix\n\n\n\n\nStructs with tags\n\n\nOnly the package \nreflect\n can access tag content. \nreflect.TypeOf()\n on a variable gives the right type; if this is a struct type, it can be indexed by \nField\n, and then the \nTag\n property can be used. For example:\n\n\n\n\nstruct_tag.go\n\n\n\n\nAnonymous fields and embedded structs\n\n\nConflicting names [TWTG p239]\n\n\n\n\nAn outer name hides an inner name. This provides a way to override a field or method.\n\n\nIf the same name appears twice at the same level, it is an error if the name is used by the program.\n\n\n\n\nMethods\n\n\n\n\nReceiver type\n\n\nMethod set: collection of all the methods on a given type \nT\n (or \n*T\n)\n\n\nNo method overloading\n\n\nA method and the type on which it acts must be defined in the same package\n\n\nPointer or value as receiver: if for a type \nT\n a method \nMeth()\n exists on \n*T\n and \nt\n is a variable of type \nT\n, then \nt.Meth()\n is automatically translated to \n(\nt).Meth()\n [TWTG p246]\n\n\n\n\nMethods on embedded types and inheritance\n\n\n\n\nOverriding: \nmethod4.go\n [TWTG p250]\n\n\nEmbedding multiple anonymous types\n\n\n\n\nEmbed functionality in a type\n\n\n\n\nAggregation (or composition): include a named field of the type of the wanted functionality\n\n\nEmbedding\n\n\n\n\nFormat specifiers\n\n\n\n\n%T\n: complete type specification\n\n\n%#v\n complete output of the instance with its fields\n\n\n\n\nInterfaces\n\n\nInterfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.\n\n\n\n\nA type doesn\u2019t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.\n\n\nA type that implements an interface can also have other functions. \n\n\nA type can implement many interfaces.\n\n\nAn interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)\n\n\n\n\nThe interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.\n\n\n\n\ninterfaces_poly.go\n\n\n\n\nInterface embedding interfaces\n\n\nAn interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]\n\n\nDetect and convert the type of an interface variable: type assertions\n\n\nWe can test if \nvarI\n (interface variable) contains at a certain moment a variable of type \nT\n with the type assertion test [TWTG p271]:\n\n\nif v, ok := varI.(T); ok {\n    // checked type assertion\n}\n\n\n\n\n\n\ntype_interfaces.go\n\n\n\n\nThe type switch\n\n\n\n\nType switch\n\n\n\n\n\n\n\nTesting if a value implements an interface\n\n\nv\n is a value and we want to test whether it implements the \nStringer\n interface:\n\n\nif sv, ok := v.(Stringer); ok {\n    fmt.Printf(\u201cv implements String(): %s\\n\u201d, sv.String()); // note: sv, not v\n}\n\n\n\n\nWriting functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.\n\n\nUsing method sets with interfaces\n\n\n\n\nPointer methods can be called with pointers.\n\n\nValue methods can be called with values.\n\n\nValue-receiver methods can be called with pointer values because they can be dereferenced first.\n\n\nPointer-receiver methods \ncannot\n be called with values, however, because the value stored inside an interface has no address.\n\n\n\n\nExamples:\n\n\n\n\nmethodset2.go\n\n\nsort.go\n\n\nsortmain.go\n\n\n\n\nEmpty Interface\n\n\nA variable of empty interface type \ninterface{}\n can through assignment receive a variable of any type.\n\n\nInterface Slice\n\n\n\n\nInterface slice\n\n\n\n\nInterface to interface\n\n\nAn interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods. \n\n\n\n\n\nReflection\n\n\nReflection is the ability of a program to examine its own structure, particularly through the types; it\u2019s a form of \nmetaprogramming\n. \nreflect\n can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods \"dynamically\".\n\n\n\n\nreflect.TypeOf\n\n\nreflect.ValueOf\n\n\n\n\n\n\n\n\n\nv.Kind()\n: returns a constant indicating the type\n\n\nv.Interface()\n: recovers the (interface) value\n\n\n\n\nExample:\n\n\n\n\nreflect1.go\n\n\n\n\nSetting a value through reflection\n\n\n\n\nSettability\n: a \nValue\n can be changed only if it is addressable and was not obtained by the use of unexported struct fields.\n\n\n\n\n\n\nReferences\n\n\n\n\n[TWTG] \nThe Way To Go: A Thorough Introduction To The Go Programming Language\n\n\n[EG] \nEffective Go\n\n\n[TGB] \nThe Go Blog", 
            "title": "Go"
        }, 
        {
            "location": "/golang/#golang", 
            "text": "Structs  Visibility  The naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.  Factory methods  Force using factory methods on a private type [TWTG p233]:  wrong := new(matrix.matrix)    // will NOT compile (matrix is private)\nright := matrix.NewMatrix(...)   // the ONLY way to instantiate a matrix  Structs with tags  Only the package  reflect  can access tag content.  reflect.TypeOf()  on a variable gives the right type; if this is a struct type, it can be indexed by  Field , and then the  Tag  property can be used. For example:   struct_tag.go   Anonymous fields and embedded structs  Conflicting names [TWTG p239]   An outer name hides an inner name. This provides a way to override a field or method.  If the same name appears twice at the same level, it is an error if the name is used by the program.   Methods   Receiver type  Method set: collection of all the methods on a given type  T  (or  *T )  No method overloading  A method and the type on which it acts must be defined in the same package  Pointer or value as receiver: if for a type  T  a method  Meth()  exists on  *T  and  t  is a variable of type  T , then  t.Meth()  is automatically translated to  ( t).Meth()  [TWTG p246]   Methods on embedded types and inheritance   Overriding:  method4.go  [TWTG p250]  Embedding multiple anonymous types   Embed functionality in a type   Aggregation (or composition): include a named field of the type of the wanted functionality  Embedding   Format specifiers   %T : complete type specification  %#v  complete output of the instance with its fields   Interfaces  Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.   A type doesn\u2019t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.  A type that implements an interface can also have other functions.   A type can implement many interfaces.  An interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)   The interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.   interfaces_poly.go   Interface embedding interfaces  An interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]  Detect and convert the type of an interface variable: type assertions  We can test if  varI  (interface variable) contains at a certain moment a variable of type  T  with the type assertion test [TWTG p271]:  if v, ok := varI.(T); ok {\n    // checked type assertion\n}   type_interfaces.go   The type switch   Type switch    Testing if a value implements an interface  v  is a value and we want to test whether it implements the  Stringer  interface:  if sv, ok := v.(Stringer); ok {\n    fmt.Printf(\u201cv implements String(): %s\\n\u201d, sv.String()); // note: sv, not v\n}  Writing functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.  Using method sets with interfaces   Pointer methods can be called with pointers.  Value methods can be called with values.  Value-receiver methods can be called with pointer values because they can be dereferenced first.  Pointer-receiver methods  cannot  be called with values, however, because the value stored inside an interface has no address.   Examples:   methodset2.go  sort.go  sortmain.go   Empty Interface  A variable of empty interface type  interface{}  can through assignment receive a variable of any type.  Interface Slice   Interface slice   Interface to interface  An interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods.    Reflection  Reflection is the ability of a program to examine its own structure, particularly through the types; it\u2019s a form of  metaprogramming .  reflect  can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods \"dynamically\".   reflect.TypeOf  reflect.ValueOf     v.Kind() : returns a constant indicating the type  v.Interface() : recovers the (interface) value   Example:   reflect1.go   Setting a value through reflection   Settability : a  Value  can be changed only if it is addressable and was not obtained by the use of unexported struct fields.    References   [TWTG]  The Way To Go: A Thorough Introduction To The Go Programming Language  [EG]  Effective Go  [TGB]  The Go Blog", 
            "title": "Golang"
        }, 
        {
            "location": "/bash/", 
            "text": "Bash\n\n\n\n\nReferences\n\n\n\n\nThe GNU Bash Reference Manual\n\n\nBash Hackers Wiki", 
            "title": "Bash"
        }, 
        {
            "location": "/bash/#bash", 
            "text": "References   The GNU Bash Reference Manual  Bash Hackers Wiki", 
            "title": "Bash"
        }, 
        {
            "location": "/c/", 
            "text": "C\n\n\n\n\nIf you think like a computer, writing C actually makes sense. \n\n\n-- \nLinus Torvalds\n\n\n\n\nFirst-class ADT\n\n\nBad:\n\n\n/* Include guards and include files omitted. */\n\n#define MAX_NO_OF_ORDERS 42\n\n/* Internal representation of a customer. */\n\ntypedef struct\n\n{\n    const char* name;\n    Address address;\n    size_t noOfOrders;\n    Order orders[MAX_NO_OF_ORDERS];\n} Customer;\n\nvoid initCustomer(Customer* theCustomer,\n                  const char* name,\n                  const Address* address);\n\nvoid placeOrder(Customer *customer, const Order* order);\n\n/* A lot of other related functions... */\n\n\n\n\nGood:\n\n\n\n\n1_FirstClassADT\n\n\n\n\nInformation hiding\n\n\nThe First-class ADT pattern will eliminate dependency problems. Thuis pattern provides a method that separates interface from implementation.\n\n\nIncomplete Types\n\n\nThe C standard (C99) allows us to declare objects of incomplete types in a context where their sizes aren\u2019t needed. \n\n\nIn the following code:\n\n\n/* Pointer to an incomplete type */\ntypedef struct Customer* CustomerPtr;\n\n\n\n\nInstances of this pointer will serve as a handle for the clients of a first-class ADT. This mechanism enforces the constraint on clients to use the provided interface functions (\nCustomer.h\n) because there is no way a client can access a field in the \nCustomer\n structure (the C language \ndoes not allow an incomplete type to be de-referenced\n). The type is considered complete as soon as the compiler detects a subsequent specifier (\nCustomer.c\n), with the same tag, and a declaration list containing the members.\n\n\nCopy Semantics\n\n\nClients only use a handle, which is declared as a pointer, to the ADT. Copies of a handle are simply pointer assignment.\n\n\nDependencies managed\n\n\nInternals of the data structure are encapsulated in the implementation and clients cannot access them. \n\n\nConsequences\n\n\nPros:\n\n\n\n\nImproved encapsulation\n\n\nLoose coupling\n\n\nControlled construction and destruction\n\n\n\n\nCons:\n\n\n\n\nExtra level of indirection\n\n\nIncreased dynamic memory usage\n\n\n\n\n\n\nReferences\n\n\n\n\n[PIC]: \nPatterns in C", 
            "title": "C"
        }, 
        {
            "location": "/c/#c", 
            "text": "If you think like a computer, writing C actually makes sense.   --  Linus Torvalds   First-class ADT  Bad:  /* Include guards and include files omitted. */\n\n#define MAX_NO_OF_ORDERS 42\n\n/* Internal representation of a customer. */\n\ntypedef struct\n\n{\n    const char* name;\n    Address address;\n    size_t noOfOrders;\n    Order orders[MAX_NO_OF_ORDERS];\n} Customer;\n\nvoid initCustomer(Customer* theCustomer,\n                  const char* name,\n                  const Address* address);\n\nvoid placeOrder(Customer *customer, const Order* order);\n\n/* A lot of other related functions... */  Good:   1_FirstClassADT   Information hiding  The First-class ADT pattern will eliminate dependency problems. Thuis pattern provides a method that separates interface from implementation.  Incomplete Types  The C standard (C99) allows us to declare objects of incomplete types in a context where their sizes aren\u2019t needed.   In the following code:  /* Pointer to an incomplete type */\ntypedef struct Customer* CustomerPtr;  Instances of this pointer will serve as a handle for the clients of a first-class ADT. This mechanism enforces the constraint on clients to use the provided interface functions ( Customer.h ) because there is no way a client can access a field in the  Customer  structure (the C language  does not allow an incomplete type to be de-referenced ). The type is considered complete as soon as the compiler detects a subsequent specifier ( Customer.c ), with the same tag, and a declaration list containing the members.  Copy Semantics  Clients only use a handle, which is declared as a pointer, to the ADT. Copies of a handle are simply pointer assignment.  Dependencies managed  Internals of the data structure are encapsulated in the implementation and clients cannot access them.   Consequences  Pros:   Improved encapsulation  Loose coupling  Controlled construction and destruction   Cons:   Extra level of indirection  Increased dynamic memory usage    References   [PIC]:  Patterns in C", 
            "title": "C"
        }, 
        {
            "location": "/iptables/", 
            "text": "iptables\n\n\n\n\nReferences\n\n\n\n\n[ITT]: \nIptables Tutorial 1.2.2", 
            "title": "iptables"
        }, 
        {
            "location": "/iptables/#iptables", 
            "text": "References   [ITT]:  Iptables Tutorial 1.2.2", 
            "title": "iptables"
        }, 
        {
            "location": "/nginx/", 
            "text": "Nginx\n\n\n\n\nReferences\n\n\n\n\n[ND]: \nnginx documentation\n\n\n[NTAG]: \nNGINX and NGINX Plus Tutorial and Admin Guide", 
            "title": "Nginx"
        }, 
        {
            "location": "/nginx/#nginx", 
            "text": "References   [ND]:  nginx documentation  [NTAG]:  NGINX and NGINX Plus Tutorial and Admin Guide", 
            "title": "Nginx"
        }, 
        {
            "location": "/vim/", 
            "text": "Vim\n\n\n\n\nReferences\n\n\n\n\n[LVVE]: Learning the vi and Vim Editors, 7th Edition\n\n\n[LVHW]: \nLearn Vimscript the Hard Way", 
            "title": "Vim"
        }, 
        {
            "location": "/vim/#vim", 
            "text": "References   [LVVE]: Learning the vi and Vim Editors, 7th Edition  [LVHW]:  Learn Vimscript the Hard Way", 
            "title": "Vim"
        }
    ]
}